#+TITLE: emacs.d
#+AUTHOR: James Conroy-Finn
#+EMAIL: james@logi.cl
#+STARTUP: content
#+OPTIONS: toc:3 num:nil ^:nil
#+LINK: org-babel http://orgmode.org/worg/org-contrib/babel/

* Introduction
  *My evil Emacs configuration* generated from the documentation you
  see before you.

  I'm in the process of documenting everything, and grouping logic
  pieces of configuration. It's quite apparent having moved everything
  into Org how much I can improve on how things are organised.
** What's in the box?
   Out of the box there are some pretty major enhancements to Emacs, including:

   - Great OS X support
   - Org mode on top of Dropbox (~~/Dropbox/Org~)
   - Projectile ready to go
   - Replacement of the built-in ~M-x~ with ~smex~
   - Smartparens
   - Use of ~ido~ everywhere

   Support for a number of languages and file formats including but
   not limited to:

   - Clojure
   - Erlang
   - Go
   - HTML
   - Haskell
   - Javascript
   - Lisp
   - Markdown
   - Python
   - Ruby
   - Ruby on Rails
   - Textile
** Minimum Emacs version
   Emacs 23 or greater. Note that Emacs 24 is required for some
   functionality, and will likely become the minimum required version
   some time soon.

   #+BEGIN_SRC emacs-lisp
     (let ((minver 23))
       (unless (>= emacs-major-version minver)
         (error "Your Emacs is too old -- this config requires v%s or higher" minver)))
   #+END_SRC
* Startup
** Benchmark begin
   Emacs startup time can be avoided through use of an Emacs client and
   server. There are occassions where Emacs has to be restarted
   however, and on these occassions it's nice when we don't have to
   wait long.

   #+BEGIN_SRC emacs-lisp
     (defun jcf/time-subtract-millis (b a)
       (* 1000.0 (float-time (time-subtract b a))))

     (defvar jcf/require-times nil
       "A list of (FEATURE . LOAD-DURATION). LOAD-DURATION is the time
       taken in milliseconds to load FEATURE.")

     (defadvice require
       (around build-require-times (feature &optional filename noerror) activate)
       "Note in `jcf/require-times' the time taken to require each feature."
       (let* ((already-loaded (memq feature features))
              (require-start-time (and (not already-loaded) (current-time))))
         (prog1
             ad-do-it
           (when (and (not already-loaded) (memq feature features))
             (add-to-list 'jcf/require-times
                          (cons feature
                                (jcf/time-subtract-millis (current-time)
                                                                require-start-time))
                          t)))))
   #+END_SRC
** Constants
   Settings that modify the behaviour of later configuration.
*** Spell check
    Enable with ~t~, disable with ~nil~.

    #+BEGIN_SRC emacs-lisp
     (defconst *spell-check-support-enabled* t)
    #+END_SRC
*** OS X
    #+BEGIN_SRC emacs-lisp
     (defconst *is-a-mac* (eq system-type 'darwin))
    #+END_SRC
** Compatibility
   #+BEGIN_SRC emacs-lisp
     (when (eval-when-compile (< emacs-major-version 24))
       (defun string-prefix-p (str1 str2 &optional ignore-case)
         "Return non-nil if STR1 is a prefix of STR2.  If IGNORE-CASE is
     non-nil, the comparison is done without paying attention to case
     differences."
         (eq t (compare-strings str1 nil nil
                                str2 0 (length str1) ignore-case))))
   #+END_SRC

   Allow recent packages to safely pass an arg to
   'called-interactively-p in older Emacsen, including 23.1.

   #+BEGIN_SRC emacs-lisp
     (let ((fn (symbol-function 'called-interactively-p)))
       (when (and (subrp fn) (zerop (cdr-safe (subr-arity fn))))
         (message "Warning: overriding called-interactively-p to support an argument.")
         (fset 'jcf/called-interactively-p fn)
         (defun called-interactively-p (&optional kind)
           "Overridden; see `jcf/called-interactively-p' for the wrapped function."
           (jcf/called-interactively-p))))
   #+END_SRC

   Help package.el work in older Emacsen, where there's no ~TRASH~ arg
   for ~'delete-directory~.

   #+BEGIN_SRC emacs-lisp
     (when (eval-when-compile (< emacs-major-version 24))
       (message "Warning: overriding delete-directory to support TRASH argument.")
       (fset 'jcf/delete-directory (symbol-function 'delete-directory))
       (defun delete-directory (directory &optional recursive trash)
         "Overridden: see `jcf/delete-directory' for the wrapped function"
         (jcf/delete-directory directory recursive)))
   #+END_SRC

   Restore removed var alias, used by ruby-electric-brace and others.

   #+BEGIN_SRC emacs-lisp
     (unless (boundp 'last-command-char)
       (defvaralias 'last-command-char 'last-command-event))
   #+END_SRC
** Utilities
*** Evaluate a variable number of expressions after a feature has been loaded
   #+BEGIN_SRC emacs-lisp
     (defmacro after-load (feature &rest body)
       "After FEATURE is loaded, evaluate BODY."
       (declare (indent defun))
       `(eval-after-load ,feature
          '(progn ,@body)))
   #+END_SRC
*** Handier way to add modes to ~auto-mode-alist~
   #+BEGIN_SRC emacs-lisp
     (defun add-auto-mode (mode &rest patterns)
       "Add entries to `auto-mode-alist' to use `MODE' for all given file
     `PATTERNS'."
       (dolist (pattern patterns)
         (add-to-list 'auto-mode-alist (cons pattern mode))))
   #+END_SRC
*** String utilities missing from core emacs
   #+BEGIN_SRC emacs-lisp
     (defun jcf/string-all-matches (regex str &optional group)
       "Find all matches for `REGEX' within `STR', returning the full match string or group `GROUP'."
       (let ((result nil)
             (pos 0)
             (group (or group 0)))
         (while (string-match regex str pos)
           (push (match-string group str) result)
           (setq pos (match-end group)))
         result))

     (defun jcf/string-rtrim (str)
       "Remove trailing whitespace from `STR'."
       (replace-regexp-in-string "[ \t\n]*$" "" str))
   #+END_SRC
*** Find the directory containing a given library
   #+BEGIN_SRC emacs-lisp
     (autoload 'find-library-name "find-func")
     (defun jcf/directory-of-library (library-name)
       "Return the directory in which the `LIBRARY-NAME' load file is found."
       (file-name-as-directory
        (file-name-directory (find-library-name library-name))))
   #+END_SRC
*** Delete the current file
   #+BEGIN_SRC emacs-lisp
     (defun delete-this-file ()
       "Delete the current file, and kill the buffer."
       (interactive)
       (or (buffer-file-name) (error "No file is currently being edited"))
       (when (yes-or-no-p (format "Really delete '%s'?"
                                  (file-name-nondirectory buffer-file-name)))
         (delete-file (buffer-file-name))
         (kill-this-buffer)))
   #+END_SRC
*** Rename the current file
   #+BEGIN_SRC emacs-lisp
     (defun rename-buffer-and-file ()
       "Rename current buffer and if the buffer is visiting a file, rename it too."
       (interactive)
       (let ((filename (buffer-file-name)))
         (if (not (and filename (file-exists-p filename)))
             (rename-buffer (read-from-minibuffer "New name: " (buffer-name)))
           (let ((new-name (read-file-name "New name: ")))
             (cond
              ((vc-backend filename) (vc-rename-file filename new-name))
              (t
               (rename-file filename new-name t)
               (set-visited-file-name new-name t t)))))))
   #+END_SRC
*** Browse current HTML file
   #+BEGIN_SRC emacs-lisp
     (defun browse-current-file ()
       "Open the current file as a URL using `browse-url'."
       (interactive)
       (let ((file-name (buffer-file-name)))
         (if (tramp-tramp-file-p file-name)
             (error "Cannot open tramp file")
           (browse-url (concat "file://" file-name)))))
   #+END_SRC
** Site Lisp
*** Add to ~load-path~

    #+BEGIN_SRC emacs-lisp
      (eval-when-compile (require 'cl))

      (defun jcf/add-subdirs-to-load-path (parent-dir)
        "Adds every non-hidden subdir of PARENT-DIR to `load-path'."
        (let* ((default-directory parent-dir))
          (progn
            (setq load-path
                  (append
                   (loop for dir in (directory-files parent-dir)
                         unless (string-match "^\\." dir)
                         collecting (expand-file-name dir))
                   load-path)))))

      (jcf/add-subdirs-to-load-path
       (expand-file-name "site-lisp/" user-emacs-directory))
    #+END_SRC

*** Grab upstream libraries

   #+BEGIN_SRC emacs-lisp
     (defun site-lisp-dir-for (name)
       (expand-file-name (format "site-lisp/%s" name) user-emacs-directory))

     (defun site-lisp-library-el-path (name)
       (expand-file-name (format "%s.el" name) (site-lisp-dir-for name)))

     (defun download-site-lisp-module (name url)
       (let ((dir (site-lisp-dir-for name)))
         (message "Downloading %s from %s" name url)
         (unless (file-directory-p dir)
           (make-directory dir t))
         (add-to-list 'load-path dir)
         (let ((el-file (site-lisp-library-el-path name)))
           (url-copy-file url el-file t nil)
           el-file)))

     (defun ensure-lib-from-url (name url)
       (unless (site-lisp-library-loadable-p name)
         (byte-compile-file (download-site-lisp-module name url))))

     (defun site-lisp-library-loadable-p (name)
       "Return whether or not the library `name' can be loaded from a
     source file under ~/.emacs.d/site-lisp/name/"
       (let ((f (locate-library (symbol-name name))))
         (and f (string-prefix-p (file-name-as-directory (site-lisp-dir-for name)) f))))
   #+END_SRC
*** Download these
    #+BEGIN_SRC emacs-lisp
      (unless (> emacs-major-version 23)
        (ensure-lib-from-url
         'package
         "http://repo.or.cz/w/emacs.git/blob_plain/1a0a666f941c99882093d7bd08ced15033bc3f0c:/lisp/emacs-lisp/package.el"))
    #+END_SRC
** Package Archives
*** Load the right package.el
    When switching between Emacs 23 and 24, we always use the bundled
    package.el in Emacs 24.

    #+BEGIN_SRC emacs-lisp
     (let ((package-el-site-lisp-dir
            (expand-file-name "site-lisp/package" user-emacs-directory)))
       (when (and (file-directory-p package-el-site-lisp-dir)
                  (> emacs-major-version 23))
         (message "Removing local package.el from load-path to avoid shadowing bundled version")
         (setq load-path (remove package-el-site-lisp-dir load-path))))

     (require 'package)
    #+END_SRC
*** Setup repositories
    Disable Marmalade.

    #+BEGIN_SRC emacs-lisp
     ;; (add-to-list
     ;;  'package-archives
     ;;  '("marmalade" . "http://marmalade-repo.org/packages/"))
    #+END_SRC

    We include the org repository for completeness, but don't normally
    use it.

    #+BEGIN_SRC emacs-lisp
     (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
    #+END_SRC

    Since version 24 Emacs includes a built-in repository of FSF
    sanctioned Emacs packages, also called ELPA and found at ELPA
    repository. If we're in Emacs 23 we add the repo ourselves.

    #+BEGIN_SRC emacs-lisp
     (when (< emacs-major-version 24)
       (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/")))
    #+END_SRC

    Milkypostman’s Emacs Lisp Package Archive otherwise known as MELPA
    (http://melpa.milkbox.net/).

    #+BEGIN_SRC emacs-lisp
     (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/"))
     (add-to-list 'package-archives '("melpa-stable" . "http://melpa-stable.milkbox.net/packages/"))
    #+END_SRC
*** GPG signatures
    If ~gpg~ can't be found, signature checking will fail, so we
    conditionally enable it according to whether ~gpg~ is available.

    #+BEGIN_SRC emacs-lisp
      (defun jcf/package-maybe-enable-signatures ()
        (setq package-check-signature (when (executable-find "gpg")
                                        'allow-unsigned)))

      (jcf/package-maybe-enable-signatures)
    #+END_SRC

    Look for ~gpg~ again after ~$PATH~ has been configured.

    #+BEGIN_SRC emacs-lisp
      (after-load 'init-exec-path
        (jcf/package-maybe-enable-signatures))
    #+END_SRC
*** On-demand installation of packages
    #+BEGIN_SRC emacs-lisp
      (defun require-package (package &optional min-version no-refresh)
        "Install given PACKAGE, optionally requiring MIN-VERSION.
      If NO-REFRESH is non-nil, the available package lists will not be
      re-downloaded in order to locate PACKAGE."
        (if (package-installed-p package min-version)
            t
          (if (or (assoc package package-archive-contents) no-refresh)
              (package-install package)
            (progn
              (package-refresh-contents)
              (require-package package min-version t)))))
    #+END_SRC
*** Fire up ~package.el~
    #+BEGIN_SRC emacs-lisp
      (package-initialize)
    #+END_SRC
*** Fullframe package list
    #+BEGIN_SRC emacs-lisp
      (require-package 'fullframe)
      (fullframe list-packages quit-window)
    #+END_SRC
*** Marmalade
  #+BEGIN_SRC emacs-lisp
    (require-package 'marmalade)

    ;;; Handy code for uploading new versions of my own packages to marmalade

    (autoload 'marmalade-upload-buffer "marmalade")

    (defun jcf/parse-git-version (s)
      "Return numeric version array parsed from S, or nil."
      (ignore-errors (version-to-list s)))

    (defun latest-version-from-git-tag ()
      (let ((versions
             (remove-if #'null
                        (mapcar #'jcf/parse-git-version
                                (split-string (shell-command-to-string "git tag"))))))
        (sort versions #'version-list-<)
        (package-version-join (car (last versions)))))

    (defun update-version-header (val)
      (save-excursion
        (goto-char (point-min))
        (re-search-forward "^;;;? ?Version:")
        (kill-line)
        (insert " " val)))

    (defun submit-tar-to-marmalade (buf)
      (interactive "bSubmit buffer library as tar: ")
      (with-current-buffer buf
        (let* ((tag (or (latest-version-from-git-tag) (error "Not tagged")))
               (library-name (file-name-nondirectory (file-name-sans-extension buffer-file-name)))
               (package-dir-name (concat library-name "-" tag))
               (temp-working-dir (make-temp-file "emacs-marmalade" t))
               (dest (expand-file-name package-dir-name temp-working-dir))
               (tar-cmd (or (executable-find "gtar")
                            (executable-find "tar")))
               (tar (concat dest ".tar")))
          (message "Building package in %s" dest)
          (make-directory dest)
          (let ((command-line (format "cp *.el %s && (cd %s && perl -spi -e 's/\\{\\{VERSION\\}\\}/%s/' *.el) && (cd %s && %s cvf %s %s)" dest dest tag temp-working-dir tar-cmd tar package-dir-name)))
            (shell-command command-line))
          (save-excursion
            (shell-command (format "open %s" temp-working-dir))
            ;; (find-file tar)
            ;; (marmalade-upload-buffer (current-buffer))
            ;; (delete-directory temp-working-dir t)
            ))))

    (defun submit-to-marmalade (buf)
      "Submit the elisp library in BUF to Marmalade."
      (interactive
       (list
        (let ((buffers (loop for b in (mapcar 'buffer-name (buffer-list))
                             when (with-current-buffer b
                                    (and buffer-file-name
                                         (eq major-mode 'emacs-lisp-mode)))
                             collect b)))
          (completing-read "Submit buffer: " buffers nil t nil nil (car buffers)))))
      (with-current-buffer buf
        (let ((tag (latest-version-from-git-tag)))
          (unless tag
            (error "Not tagged"))
          (update-version-header tag)
          (marmalade-upload-buffer buf)
          (revert-buffer t t)
          (message "Submitted version %s to marmalade" tag))))
  #+END_SRC
** PATH
   Use [[https://github.com/purcell/exec-path-from-shell][~exec-path-from-shell~]] to pull ~PATH~ configuration from the
   user's shell.

   From the exec-path-from-shell [[https://github.com/purcell/exec-path-from-shell/blob/dccbb54b18950d64885daea9e98e49f15af1f0c9/README.md][README]]:

   #+BEGIN_QUOTE
   On OS X, an Emacs instance started from the graphical user interface
   will have a different environment than a shell in a terminal window,
   because OS X does not run a shell during the login. Obviously this
   will lead to unexpected results when calling external utilities like
   make from Emacs.
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
     (require-package 'exec-path-from-shell)

     (after-load 'exec-path-from-shell
       (dolist (var '("SSH_AUTH_SOCK" "SSH_AGENT_PID" "GPG_AGENT_INFO" "LANG" "LC_CTYPE"))
         (add-to-list 'exec-path-from-shell-variables var)))

     (when (memq window-system '(mac ns))
       (exec-path-from-shell-initialize))
   #+END_SRC

** First packages
*** ~wgrep~
    [[https://github.com/mhayashi1120/Emacs-wgrep][~wgrep~]] makes the ~grep~, and ~ag~ buffers writable so you can make
    changes to your search results.

    #+BEGIN_SRC emacs-lisp
      (require-package 'wgrep)
    #+END_SRC
*** ~project-local-variables~
    The [[http://www.emacswiki.org/emacs/ProjectLocalVariables][~project-local-variables~]] package looks for a ~.emacs-project~
    file in your current directory, and evaluates its contents.

    This poses an obvious security risk as any arbitrary Lisp code will
    be evaluated when found.

    Consider replacing with the built-in [[http://www.emacswiki.org/emacs/DirectoryVariables][~directory-variables~]].

    #+BEGIN_SRC emacs-lisp
      (require-package 'project-local-variables)
    #+END_SRC
*** ~diminish~
    [[http://www.emacswiki.org/emacs/DiminishedModes][Diminish]] lets you fight modeline clutter by removing or abbreviating
    minor mode indicators.

    #+BEGIN_SRC emacs-lisp
      (require-package 'diminish)
    #+END_SRC

    When Emacs starts up, it contains a buffer named *scratch*, which is
    provided for evaluating Emacs Lisp expressions interactively. Its
    major mode is Lisp Interaction mode. You can also enable Lisp
    Interaction mode by typing ~M-x lisp-interaction-mode~.

    #+BEGIN_SRC emacs-lisp
      (require-package 'scratch)
    #+END_SRC
*** ~mwe-log-commands~
    ~[[http://www.foldr.org/~michaelw/emacs/mwe-log-commands.el][mwe-log-commands~]] is logs is designed for use during demos, logging
    keystrokes into a designated buffer, along with the command bound to
    them.

    #+BEGIN_SRC emacs-lisp
     (require-package 'mwe-log-commands)
    #+END_SRC
* Configuration
** Frame hooks
   Run hooks based on whether we're using Emacs via console or GUI.

   #+BEGIN_SRC emacs-lisp
     (defvar after-make-console-frame-hooks '()
       "Hooks to run after creating a new TTY frame")
     (defvar after-make-window-system-frame-hooks '()
       "Hooks to run after creating a new window-system frame")

     (defun run-after-make-frame-hooks (frame)
       "Run configured hooks in response to the newly-created FRAME.
     Selectively runs either `after-make-console-frame-hooks' or
     `after-make-window-system-frame-hooks'"
       (with-selected-frame frame
         (run-hooks (if window-system
                        'after-make-window-system-frame-hooks
                      'after-make-console-frame-hooks))))

     (add-hook 'after-make-frame-functions 'run-after-make-frame-hooks)
   #+END_SRC
** xterm
   Fix arrow keys in ~xterm~? This was here when I arrived, and I'm not
   using xterm so just leaving it here for now.

   #+BEGIN_SRC emacs-lisp
     (defun fix-up-xterm-control-arrows ()
       (let ((map (if (boundp 'input-decode-map)
                      input-decode-map
                    function-key-map)))
         (define-key map "\e[1;5A" [C-up])
         (define-key map "\e[1;5B" [C-down])
         (define-key map "\e[1;5C" [C-right])
         (define-key map "\e[1;5D" [C-left])
         (define-key map "\e[5A"   [C-up])
         (define-key map "\e[5B"   [C-down])
         (define-key map "\e[5C"   [C-right])
         (define-key map "\e[5D"   [C-left])))
   #+END_SRC

   Mouse in a terminal (use shift to paste with middle button).

   #+BEGIN_SRC emacs-lisp
     (defun jcf/enable-mouse-in-terminal ()
       (xterm-mouse-mode 1)
       (when (fboundp 'mwheel-install)
         (mwheel-install)))
   #+END_SRC

   Run the above fixes using the frame hook
   ~after-make-console-frame-hooks~.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'after-make-console-frame-hooks
               (lambda ()
                 (when (< emacs-major-version 23)
                   (fix-up-xterm-control-arrows))
                 (jcf/enable-mouse-in-terminal)))
   #+END_SRC
** Interface
*** Themes
    Use [[https://github.com/bbatsov/zenburn-emacs][Zenburn]], which is a dark theme that works well with a large
    number of Emacs modes.

    #+BEGIN_SRC emacs-lisp
      (require-package 'zenburn-theme)
      (load-theme 'zenburn t)
    #+END_SRC
*** GUI
**** Stop ~C-z~ from minimizing windows
     #+BEGIN_SRC emacs-lisp
       (defun maybe-suspend-frame ()
         (interactive)
         (unless (and *is-a-mac* window-system)
           (suspend-frame)))

       (global-set-key (kbd "C-z") 'maybe-suspend-frame)
     #+END_SRC
**** Supress GUI features
     #+BEGIN_SRC emacs-lisp
       (setq use-file-dialog nil)
       (setq use-dialog-box nil)
       (setq inhibit-startup-screen t)
       (setq inhibit-startup-echo-area-message t)
     #+END_SRC
**** Indicate empty lines in left fringe
     #+BEGIN_SRC emacs-lisp
       (setq indicate-empty-lines t)
     #+END_SRC
**** Hide toolbar
     #+BEGIN_SRC emacs-lisp
       (when (fboundp 'tool-bar-mode)
         (tool-bar-mode -1))
     #+END_SRC
**** Hide scrollbar
     #+BEGIN_SRC emacs-lisp
       (when (fboundp 'set-scroll-bar-mode)
         (set-scroll-bar-mode nil))
     #+END_SRC
**** Narrow fringe
     #+BEGIN_SRC emacs-lisp
       (when (fboundp 'fringe-mode)
         (fringe-mode 4))
     #+END_SRC
**** Toggle fullscreen
     Command-Option-f to toggle fullscreen mode.

     #+BEGIN_SRC emacs-lisp
       (when (and *is-a-mac* (fboundp 'toggle-frame-fullscreen))
         ;; Hint: Customize `ns-use-native-fullscreen'
         (global-set-key (kbd "M-ƒ") 'toggle-frame-fullscreen))
     #+END_SRC
**** Adjust opacity
     #+BEGIN_SRC emacs-lisp
       (defun jcf/adjust-opacity (frame incr)
         (let* ((oldalpha (or (frame-parameter frame 'alpha) 100))
                (newalpha (+ incr oldalpha)))
           (when (and (<= frame-alpha-lower-limit newalpha) (>= 100 newalpha))
             (modify-frame-parameters frame (list (cons 'alpha newalpha))))))

       (global-set-key (kbd "M-C-8") '(lambda () (interactive) (jcf/adjust-opacity nil -5)))
       (global-set-key (kbd "M-C-9") '(lambda () (interactive) (jcf/adjust-opacity nil 5)))
       (global-set-key (kbd "M-C-0") '(lambda () (interactive) (modify-frame-parameters nil `((alpha . 100)))))
     #+END_SRC

**** ~menu-bar-lines~
     The number of lines to allocate at the top of the frame for a menu
     bar. The default is 1 if Menu Bar mode is enabled, and 0
     otherwise. See [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Menu-Bars.html#Menu-Bars][Menu Bars]] for more information.

     #+BEGIN_SRC emacs-lisp
       (add-hook 'after-make-frame-functions
                 (lambda (frame)
                   (with-selected-frame frame
                     (unless window-system
                       (set-frame-parameter nil 'menu-bar-lines 0)))))
     #+END_SRC
**** Frame title
     #+BEGIN_SRC emacs-lisp
       (setq frame-title-format
             '((:eval (if (buffer-file-name)
                          (abbreviate-file-name (buffer-file-name))
                        "%b"))))
     #+END_SRC
**** Line spacing fix
     Non-zero values for ~line-spacing~ can mess up ansi-term and
     similar modes, so we zero it explicitly in those cases.

     #+BEGIN_SRC emacs-lisp
       (add-hook 'term-mode-hook
                 (lambda ()
                   (set (make-local-variable 'line-spacing)
                        0)))
     #+END_SRC
** Uniquify
   Improved naming of buffers for files with identical names.
   #+BEGIN_SRC emacs-lisp
     (require 'uniquify)

     (setq uniquify-buffer-name-style 'reverse)
     (setq uniquify-separator " • ")
     (setq uniquify-after-kill-buffer-p t)
     (setq uniquify-ignore-buffers-re "^\\*")
    #+END_SRC
** Yes or No
   #+BEGIN_SRC emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC
* Fonts
** Character sets
   #+BEGIN_SRC emacs-lisp
     (defcustom jcf/force-default-font-for-symbols nil
       "When non-nil, force Emacs to use your default font for symbols."
       :type 'boolean)

     (defun jcf/maybe-use-default-font-for-symbols ()
       "Force Emacs to render symbols using the default font, if so configured."
       (when jcf/force-default-font-for-symbols
         (set-fontset-font "fontset-default" 'symbol (face-attribute 'default :family))))

     (add-hook 'after-init-hook 'jcf/maybe-use-default-font-for-symbols)
   #+END_SRC
** Changing font sizes
   #+BEGIN_SRC emacs-lisp
     (require 'cl)

     (defun jcf/font-name-replace-size (font-name new-size)
       (let ((parts (split-string font-name "-")))
         (setcar (nthcdr 7 parts) (format "%d" new-size))
         (mapconcat 'identity parts "-")))

     (defun jcf/increment-default-font-height (delta)
       "Adjust the default font height by DELTA on every frame.
     Emacs will keep the pixel size of the frame approximately the
     same.  DELTA should be a multiple of 10, to match the units used
     by the :height face attribute."
       (let* ((new-height (+ (face-attribute 'default :height) delta))
              (new-point-height (/ new-height 10)))
         (dolist (f (frame-list))
           (with-selected-frame f
             ;; Latest 'set-frame-font supports a "frames" arg, but
             ;; we cater to Emacs 23 by looping instead.
             (set-frame-font (jcf/font-name-replace-size
                              (face-font 'default)
                              new-point-height)
                             t)))
         (set-face-attribute 'default nil :height new-height)
         (message "default font size is now %d" new-point-height)))

     (defun jcf/increase-default-font-height ()
       (interactive)
       (jcf/increment-default-font-height 10))

     (defun jcf/decrease-default-font-height ()
       (interactive)
       (jcf/increment-default-font-height -10))

     (global-set-key (kbd "C-M-=") 'jcf/increase-default-font-height)
     (global-set-key (kbd "C-M--") 'jcf/decrease-default-font-height)
   #+END_SRC
** Default font on OS X
   #+BEGIN_SRC emacs-lisp
     (if *is-a-mac*
         (set-frame-font "-*-Source Code Pro-normal-normal-normal-*-12-*-*-*-m-0-iso10646-1"))
   #+END_SRC
* OS X
** Input
   Sets up a number of Mac-specific key bindings and mouse settings.

   1. Use ~command~ as ~meta~
   2. Leave ~option~ alone
   3. Make mouse wheel/trackpad scrolling less jerky
   4. ~M-`~ to switch frame
   5. Hide Emacs with ~M-h~
   6. Hide others with ~M-H~
   7. Copy and paste with ~M-c~ and ~M-v~ respectively

   #+BEGIN_SRC emacs-lisp
     (when *is-a-mac*
       (setq mac-command-modifier 'meta)
       (setq mac-option-modifier 'none)
       (setq mouse-wheel-scroll-amount '(1
                                         ((shift) . 5)
                                         ((control))))
       (global-set-key (kbd "M-`") 'ns-next-frame)
       (global-set-key (kbd "M-h") 'ns-do-hide-emacs)
       (after-load 'nxml-mode
         (define-key nxml-mode-map (kbd "M-h") nil))
       ;; What describe-key reports for cmd-option-h
       (global-set-key (kbd "M-ˍ") 'ns-do-hide-others)
       (global-set-key (kbd "M-v") 'cua-paste)
       (global-set-key (kbd "M-c") 'cua-copy-region))
   #+END_SRC
** Proxy
   Pick up ~http_proxy~ & ~https_proxy~ from Mac system config using
   [[http://www.cs.usyd.edu.au/~massad/project-proxy-config.html][proxy-config]].

   #+BEGIN_SRC emacs-lisp
     (when (and *is-a-mac* (executable-find "proxy-config"))
       (defun mac-configured-proxy (proto)
         (jcf/string-rtrim
          (shell-command-to-string
           (concat "proxy-config " (cdr (assoc-string proto '(("http" . "-h")
                                                              ("https" . "-s"))))))))

       (defun extract-host-and-port (url-string)
         (if (string-match "^[a-z]+://\\([^/]+\\)" url-string)
           (match-string 1 url-string)
           url-string))

       (defun assq-delete-all-with-test (k l &optional test)
         (let ((test-func (or test #'eq)))
           (loop for entry in l
                 unless (funcall test-func k (car entry))
                 collect entry)))

       (defun mac-set-proxy-vars ()
         (interactive)
         (require 'url)
         (loop for proto in '("http" "https")
               for proxy = (mac-configured-proxy proto)
               do
               (setenv (concat proto "_proxy" proxy))
               (setq url-proxy-services
                     (append (assq-delete-all-with-test proto
                                                        url-proxy-services
                                                        #'equal)
                             (if (not (equal "" proxy))
                                 (list (cons proto (extract-host-and-port proxy)))))))
         (message "Proxy variables updated")))
   #+END_SRC
** Location
   #+BEGIN_SRC emacs-lisp
     (when *is-a-mac*
           (require-package 'osx-location))
   #+END_SRC
* Evil
** Setup
   #+BEGIN_SRC emacs-lisp
     (require-package 'evil)
   #+END_SRC
** Fire up the modes
   Activates all of the evil extensions installed above, making sure
   to [[http://j.mp/1i0vLSP][load evil-leader]] before evil itself.

   #+BEGIN_SRC emacs-lisp
     (global-evil-leader-mode 1)
     (evil-mode 1)
     (global-evil-surround-mode 1)
     (global-evil-matchit-mode 1)
     (evil-exchange-install)
     (require 'evil-jumper)
   #+END_SRC
** Configuration
   #+BEGIN_SRC emacs-lisp
     (setq evil-default-cursor t)
     (setq evil-insert-state-message nil)
     (setq evil-visual-state-message nil)
     (setq evil-mode-line-format 'before)

     (setq evil-search-module 'evil-search)

     (setq evil-emacs-state-cursor  '("red" box))
     (setq evil-normal-state-cursor '("gray" box))
     (setq evil-visual-state-cursor '("gray" box))
     (setq evil-insert-state-cursor '("gray" bar))
     (setq evil-motion-state-cursor '("gray" box))
   #+END_SRC
*** Yank to end of line
    #+BEGIN_SRC emacs-lisp
      (define-key evil-normal-state-map "Y" (kbd "y$"))
    #+END_SRC
*** Delete and balance windows
    Used in some ~<leader>~ bindings below.

    #+BEGIN_SRC emacs-lisp
      (defun jcf/delete-window ()
        "Delete the current window, and rebalance remaining windows."
        (interactive)
        (delete-window)
        (balance-windows))

      (defun jcf/split-window-horizontally ()
        "Create a new horizontal split and rebalance windows."
        (interactive)
        (split-window-horizontally)
        (balance-windows))

      (defun jcf/split-window-vertically ()
        "Create a new vertical split and rebalance windows."
        (interactive)
        (split-window-vertically)
        (balance-windows))
    #+END_SRC
*** Use global tags
    #+BEGIN_SRC emacs-lisp
      (define-key evil-motion-state-map (kbd "C-]") 'ggtags-find-tag-dwim)
    #+END_SRC
*** Space to repeat ~find-char~
    #+BEGIN_SRC emacs-lisp
      (define-key evil-normal-state-map (kbd "SPC") 'evil-repeat-find-char)
      (define-key
        evil-normal-state-map (kbd "S-SPC") 'evil-repeat-find-char-reverse)
    #+END_SRC
*** Use ~escape~ to quit everywhere
    #+BEGIN_SRC emacs-lisp
      ;; Use escape to quit, and not as a meta-key.
      (define-key evil-normal-state-map [escape] 'keyboard-quit)
      (define-key evil-visual-state-map [escape] 'keyboard-quit)
      (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
      (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
      (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
      (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
      (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
    #+END_SRC
*** ~C-hjkl~ to move around windows
    #+BEGIN_SRC emacs-lisp
      (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
      (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
      (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
      (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)
    #+END_SRC
*** Lazy ex with ~;~
    #+BEGIN_SRC emacs-lisp
      (define-key evil-normal-state-map ";" 'evil-ex)
      (define-key evil-visual-state-map ";" 'evil-ex)
    #+END_SRC
*** Initial evil state per mode
    #+BEGIN_SRC emacs-lisp
      (loop for (mode . state)
            in '((ielm-mode . insert)
                 (nrepl-mode . insert)
                 (shell-mode . insert)
                 (git-rebase-mode . emacs)
                 (term-mode . emacs)
                 (help-mode . emacs)
                 (helm-grep-mode . emacs)
                 (grep-mode . emacs)
                 (bc-menu-mode . emacs)
                 (magit-branch-manager-mode . emacs)
                 (rdictcc-buffer-mode . emacs)
                 (dired-mode . normal)
                 (wdired-mode . normal))
            do (evil-set-initial-state mode state))
    #+END_SRC
*** Magit from avsej
    #+BEGIN_SRC emacs-lisp
      (evil-add-hjkl-bindings magit-log-mode-map 'emacs)
      (evil-add-hjkl-bindings magit-commit-mode-map 'emacs)
      (evil-add-hjkl-bindings magit-branch-manager-mode-map 'emacs
        "K" 'magit-discard-item
        "L" 'magit-key-mode-popup-logging)
      (evil-add-hjkl-bindings magit-status-mode-map 'emacs
        "K" 'magit-discard-item
        "l" 'magit-key-mode-popup-logging
        "h" 'magit-toggle-diff-refine-hunk)
    #+END_SRC
*** Scroll when searching
    #+BEGIN_SRC emacs-lisp
      (defadvice evil-search-next
          (after advice-for-evil-search-next activate)
        (evil-scroll-line-to-center (line-number-at-pos)))

      (defadvice evil-search-previous
          (after advice-for-evil-search-previous activate)
        (evil-scroll-line-to-center (line-number-at-pos)))
    #+END_SRC
** Extensions
*** Exchange
    An [[https://github.com/Dewdrops/evil-exchange][Emacs port]] of [[https://github.com/tommcdo/vim-exchange][vim-exchange]], designed to make it easier to
    exchange two regions.

    #+BEGIN_SRC emacs-lisp
      (require-package 'evil-exchange)
    #+END_SRC
*** Indent Textobject
    [[https://github.com/cofi/evil-indent-textobject][evil-indent-text-object]] defines textobjects based on indentation.

    #+BEGIN_SRC emacs-lisp
      (require-package 'evil-indent-textobject)
    #+END_SRC
*** Leader
    [[https://github.com/cofi/evil-leader][evil-leader]] adds support for Vim's venerable ~<leader>~ key, which
    any Vim user will be very accustomed to.

    #+BEGIN_SRC emacs-lisp
      (require-package 'evil-leader)
      (evil-leader/set-leader ",")

      (evil-leader/set-key
        "a"  'projectile-toggle-between-implementation-and-test
        "b"  'ibuffer
        "db" 'kill-buffer
        "dw" 'jcf/delete-window
        "eb" 'eval-buffer
        "ed" 'eval-defun
        "ee" 'eval-expression
        "es" 'eval-last-sexp
        "er" 'eval-region
        "fb" 'ido-switch-buffer
        "fd" 'ido-dired
        "ff" 'ido-find-file
        "fj" 'dired-jump
        "gb" 'magit-blame-mode
        "gc" 'magit-commit
        "gl" 'magit-log
        "gs" 'magit-status
        "hf" 'describe-function
        "hm" 'describe-mode
        "hp" 'describe-package
        "hv" 'describe-variable
        "pb" 'projectile-switch-to-buffer
        "pd" 'projectile-switch-project
        "pf" 'projectile-find-file
        "sd" 'jcf/delete-window
        "sf" 'delete-other-windows
        "ss" 'jcf/split-window-horizontally
        "sv" 'jcf/split-window-vertically
        "w"  'save-buffer
        "x"  'smex)
    #+END_SRC
**** ~org-mode~ bindings
    #+BEGIN_SRC emacs-lisp
      (evil-leader/set-key-for-mode 'org-mode
        "ot" 'org-todo
        "os" 'org-sort-list)
    #+END_SRC
**** ~clojure-mode~ bindings
    #+BEGIN_SRC emacs-lisp
      (evil-leader/set-key-for-mode 'clojure-mode
        "v" 'clojure-test-run-test
        "V" 'clojure-test-run-tests
        "cc" 'cider-connect
        "cj" 'cider-jack-in
        "cq" 'cider-quit
        "eb" 'cider-eval-buffer
        "ed" 'cider-eval-defun-at-point
        "es" 'cider-eval-last-sexp
        "er" 'cider-eval-region
        "rs" 'cljr-sort-ns
        "rr" 'cljr-add-require-to-ns
        "ru" 'cljr-add-use-to-ns)
    #+END_SRC
**** ~ruby-mode~ bindings
    #+BEGIN_SRC emacs-lisp
      (evil-leader/set-key-for-mode 'ruby-mode
        "v" 'rspec-verify
        "V" 'rspec-verify-all)
    #+END_SRC
**** ~feature-mode~ bindings
    #+BEGIN_SRC emacs-lisp
      (evil-leader/set-key-for-mode 'feature-mode
        "v" 'feature-verify-scenario-at-pos
        "V" 'feature-verify-all-scenarios-in-buffer)
    #+END_SRC
*** Extended ~%~ matches
    [[https://github.com/redguardtoo/evil-matchit][evil-matchit]] is a port of [[http://www.vim.org/scripts/script.php?script_id%3D39][matchit.vim]] by Benji Fisher. Matchit
    enhances ~%~ to match HTML tags, ~do~/~end~ blocks and more.

    #+BEGIN_SRC emacs-lisp
      (require-package 'evil-matchit)
    #+END_SRC
*** NERD commenter
    I tend to use Emacs' built-in ~comment-dwim~ more than
    [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]], but it's here in case I decide to regress.

    #+BEGIN_SRC emacs-lisp
      (require-package 'evil-nerd-commenter)
    #+END_SRC
*** Numbers
    Another one from [[https://github.com/cofi][Michael Markert]] (perhaps better known as cofi),
    [[https://github.com/cofi/evil-numbers][evil-numbers]] enhances ~C-a~ and ~C-x~ in a similar way to Tim
    Pope's [[https://github.com/tpope/vim-speeddating][speeddating.vim]].

    #+BEGIN_SRC emacs-lisp
      (require-package 'evil-numbers)

      (define-key evil-normal-state-map (kbd "C-A")
        'evil-numbers/inc-at-pt)
      (define-key evil-normal-state-map (kbd "C-S-A")
        'evil-numbers/dec-at-pt)
    #+END_SRC
*** Visual star
    #+BEGIN_SRC emacs-lisp
      (require-package 'evil-visualstar)
    #+END_SRC
*** ~goto-chg~
    #+BEGIN_SRC emacs-lisp
      (require-package 'goto-chg)
    #+END_SRC
*** Surround
    #+BEGIN_SRC emacs-lisp
      (require-package 'evil-surround)
    #+END_SRC
*** Jumper
    #+BEGIN_SRC emacs-lisp
      (require-package 'evil-jumper)
    #+END_SRC
* Key Chord
  #+BEGIN_QUOTE
  Key-chord lets you bind commands to combination of key-strokes. Here
  a "key chord" means two keys pressed simultaneously, or a single key
  quickly pressed twice.
  #+END_QUOTE

  http://www.emacswiki.org/emacs/KeyChord

  #+BEGIN_SRC emacs-lisp
     (require-package 'key-chord)

     (setq key-chord-two-keys-delay 0.05)

     (key-chord-mode 1)
     (key-chord-define evil-insert-state-map "jj" 'evil-normal-state)
  #+END_SRC
* Editing
** Unfill
  #+BEGIN_SRC emacs-lisp
    (require-package 'unfill)
   #+END_SRC
** Electric pair mode
   #+BEGIN_SRC emacs-lisp
    (when (fboundp 'electric-pair-mode)
      (setq-default electric-pair-mode 1))
   #+END_SRC
** Some basic preferences
   #+BEGIN_SRC emacs-lisp
    (setq-default
     blink-cursor-delay 0
     blink-cursor-interval 0.4
     bookmark-default-file (expand-file-name ".bookmarks.el" user-emacs-directory)
     buffers-menu-max-size 30
     case-fold-search t
     column-number-mode t
     compilation-scroll-output t
     delete-selection-mode t
     ediff-split-window-function 'split-window-horizontally
     ediff-window-setup-function 'ediff-setup-windows-plain
     grep-highlight-matches t
     grep-scroll-output t
     indent-tabs-mode nil
     line-spacing 0.2
     make-backup-files nil
     mouse-yank-at-point t
     next-line-add-newlines nil
     require-final-newline t
     save-interprogram-paste-before-kill t
     scroll-preserve-screen-position 'always
     set-mark-command-repeat-pop t
     show-trailing-whitespace t
     tooltip-delay 1.5
     truncate-lines nil
     truncate-partial-width-windows nil
     visible-bell t)

    (when *is-a-mac*
      (setq-default locate-command "mdfind"))

    (global-auto-revert-mode)
    (setq global-auto-revert-non-file-buffers t
          auto-revert-verbose nil)

    (transient-mark-mode t)
   #+END_SRC
** Whitespace
   #+BEGIN_SRC emacs-lisp
    (defun jcf/no-trailing-whitespace ()
      "Turn off display of trailing whitespace in this buffer."
      (setq show-trailing-whitespace nil))

    ;; But don't show trailing whitespace in SQLi, inf-ruby etc.
    (dolist (hook '(special-mode-hook
                    eshell-mode-hook
                    eww-mode
                    term-mode-hook
                    comint-mode-hook
                    compilation-mode-hook
                    twittering-mode-hook
                    minibuffer-setup-hook))
      (add-hook hook #'jcf/no-trailing-whitespace))

    (require-package 'whitespace-cleanup-mode)
    (global-whitespace-cleanup-mode t)
   #+END_SRC
** Newline behaviour
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "RET") 'newline-and-indent)
     (defun jcf/newline-at-end-of-line ()
       "Move to end of line, enter a newline, and reindent."
       (interactive)
       (move-end-of-line 1)
       (newline-and-indent))

     (global-set-key (kbd "S-<return>") 'jcf/newline-at-end-of-line)
   #+END_SRC
** Workaround for subword not being available
   See https://github.com/purcell/emacs.d/issues/138 for more
   information.

   #+BEGIN_SRC emacs-lisp
     (when (eval-when-compile (string< "24.3.1" emacs-version))
       (after-load 'subword
         (diminish 'subword-mode)))
   #+END_SRC
** Prettify symbols
   #+BEGIN_SRC emacs-lisp
     (when (fboundp 'global-prettify-symbols-mode)
       (global-prettify-symbols-mode))
   #+END_SRC
** Undo tree
   #+BEGIN_SRC emacs-lisp
    (require-package 'undo-tree)
    (global-undo-tree-mode)
    (diminish 'undo-tree-mode)
   #+END_SRC
** Highlight symbols
   #+BEGIN_SRC emacs-lisp
    (require-package 'highlight-symbol)
    (dolist (hook '(prog-mode-hook html-mode-hook))
      (add-hook hook 'highlight-symbol-mode)
      (add-hook hook 'highlight-symbol-nav-mode))
    (eval-after-load 'highlight-symbol
      '(diminish 'highlight-symbol-mode))
   #+END_SRC
** Zap up to char
   #+BEGIN_SRC emacs-lisp
    (autoload 'zap-up-to-char "misc" "Kill up to, but not including ARGth occurrence of CHAR.")
    (global-set-key (kbd "M-Z") 'zap-up-to-char)
   #+END_SRC
** Don't disable narrowing commands
   #+BEGIN_SRC emacs-lisp
    (put 'narrow-to-region 'disabled nil)
    (put 'narrow-to-page 'disabled nil)
    (put 'narrow-to-defun 'disabled nil)
   #+END_SRC
** Show matching parens
   #+BEGIN_SRC emacs-lisp
    (show-paren-mode 1)
   #+END_SRC
** Expand region
   #+BEGIN_SRC emacs-lisp
    (require-package 'expand-region)
    (global-set-key (kbd "C-=") 'er/expand-region)
   #+END_SRC
** Don't disable case-change functions
   #+BEGIN_SRC emacs-lisp
    (put 'upcase-region 'disabled nil)
    (put 'downcase-region 'disabled nil)
   #+END_SRC
** CUA selection mode for rectangles
   #+BEGIN_SRC emacs-lisp
    (cua-selection-mode t)
   #+END_SRC
** Selection bindings
   M-x without meta.

   #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-x C-m") 'execute-extended-command)
   #+END_SRC

   Vim-like alternatives to M-^ and C-u M-^.

   #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-c j") 'join-line)
    (global-set-key (kbd "C-c J") (lambda () (interactive) (join-line 1)))

    (global-set-key (kbd "C-.") 'set-mark-command)
    (global-set-key (kbd "C-x C-.") 'pop-global-mark)
   #+END_SRC
** Ace Jump
   #+BEGIN_SRC emacs-lisp
    (require-package 'ace-jump-mode)
    (global-set-key (kbd "C-;") 'ace-jump-mode)
    (global-set-key (kbd "C-:") 'ace-jump-word-mode)
   #+END_SRC
** Multiple cursors
   #+BEGIN_SRC emacs-lisp
    (require-package 'multiple-cursors)
   #+END_SRC

   Key bindings:

   #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
    (global-set-key (kbd "C->") 'mc/mark-next-like-this)
    (global-set-key (kbd "C-+") 'mc/mark-next-like-this)
    (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
   #+END_SRC

   From active region to multiple cursors:

   #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-c c r") 'set-rectangular-region-anchor)
    (global-set-key (kbd "C-c c c") 'mc/edit-lines)
    (global-set-key (kbd "C-c c e") 'mc/edit-ends-of-lines)
    (global-set-key (kbd "C-c c a") 'mc/edit-beginnings-of-lines)
   #+END_SRC
** Disable left and right arrow key bindings
   #+BEGIN_SRC emacs-lisp
    (global-unset-key [M-left])
    (global-unset-key [M-right])
   #+END_SRC
** Delete to beginning of line
   #+BEGIN_SRC emacs-lisp
     (defun kill-back-to-indentation ()
       "Kill from point back to the first non-whitespace character on
       the line."
       (interactive)
       (let ((prev-pos (point)))
         (back-to-indentation)
         (kill-region (point) prev-pos)))

     (global-set-key (kbd "C-M-<backspace>") 'kill-back-to-indentation)
   #+END_SRC
** Page break lines
   #+BEGIN_SRC emacs-lisp
     (require-package 'page-break-lines)
     (global-page-break-lines-mode)
     (diminish 'page-break-lines-mode)
   #+END_SRC
** Fill column indicator
   #+BEGIN_SRC emacs-lisp
     (when (eval-when-compile (> emacs-major-version 23))
       (require-package 'fill-column-indicator)
       (defun jcf/prog-mode-fci-settings ()
         (turn-on-fci-mode)
         (when show-trailing-whitespace
           (set (make-local-variable 'whitespace-style) '(face trailing))
           (whitespace-mode 1)))

       ;;(add-hook 'prog-mode-hook 'jcf/prog-mode-fci-settings)

       (defun jcf/fci-enabled-p ()
         (and (boundp 'fci-mode) fci-mode))

       (defvar jcf/fci-mode-suppressed nil)
       (defadvice popup-create (before suppress-fci-mode activate)
         "Suspend fci-mode while popups are visible"
         (let ((fci-enabled (jcf/fci-enabled-p)))
           (when fci-enabled
             (set (make-local-variable 'jcf/fci-mode-suppressed) fci-enabled)
             (turn-off-fci-mode))))
       (defadvice popup-delete (after restore-fci-mode activate)
         "Restore fci-mode when all popups have closed"
         (when (and jcf/fci-mode-suppressed
                    (null popup-instances))
           (setq jcf/fci-mode-suppressed nil)
           (turn-on-fci-mode)))

       ;; Regenerate fci-mode line images after switching themes
       (defadvice enable-theme (after recompute-fci-face activate)
         (dolist (buffer (buffer-list))
           (with-current-buffer buffer
             (when (jcf/fci-enabled-p)
               (turn-on-fci-mode))))))
   #+END_SRC
** Move lines
   Shift lines up and down with M-up and M-down. When smartparens is
   enabled, it will use those keybindings. For this reason, you might
   prefer to use M-S-up and M-S-down, which will work even in lisp
   modes.

   #+BEGIN_SRC emacs-lisp
     (require-package 'move-dup)
     (global-set-key [M-up] 'md/move-lines-up)
     (global-set-key [M-down] 'md/move-lines-down)
     (global-set-key [M-S-up] 'md/move-lines-up)
     (global-set-key [M-S-down] 'md/move-lines-down)

     (global-set-key (kbd "C-c p") 'md/duplicate-down)
   #+END_SRC
** Fix backward-up-list to understand quotes, see http://bit.ly/h7mdIL
   #+BEGIN_SRC emacs-lisp
     (defun backward-up-sexp (arg)
       "Jump up to the start of the ARG'th enclosing sexp."
       (interactive "p")
       (let ((ppss (syntax-ppss)))
         (cond ((elt ppss 3)
                (goto-char (elt ppss 8))
                (backward-up-sexp (1- arg)))
               ((backward-up-list arg)))))

     (global-set-key [remap backward-up-list] 'backward-up-sexp) ; C-M-u, C-M-up
   #+END_SRC
** Cut/copy current line if no region active
   #+BEGIN_SRC emacs-lisp
     (require-package 'whole-line-or-region)

     (whole-line-or-region-mode t)
     (diminish 'whole-line-or-region-mode)
     (make-variable-buffer-local 'whole-line-or-region-mode)

     (defun suspend-mode-during-cua-rect-selection (mode-name)
       "Add an advice to suspend `MODE-NAME' while selecting a CUA rectangle."
       (let ((flagvar (intern (format "%s-was-active-before-cua-rectangle" mode-name)))
             (advice-name (intern (format "suspend-%s" mode-name))))
         (eval-after-load 'cua-rect
           `(progn
              (defvar ,flagvar nil)
              (make-variable-buffer-local ',flagvar)
              (defadvice cua--activate-rectangle (after ,advice-name activate)
                (setq ,flagvar (and (boundp ',mode-name) ,mode-name))
                (when ,flagvar
                  (,mode-name 0)))
              (defadvice cua--deactivate-rectangle (after ,advice-name activate)
                (when ,flagvar
                  (,mode-name 1)))))))

     (suspend-mode-during-cua-rect-selection 'whole-line-or-region-mode)
   #+END_SRC
** Indentation-aware open line
   #+BEGIN_SRC emacs-lisp
     (defun jcf/open-line-with-reindent (n)
       "A version of `open-line' which reindents the start and end
     positions.

     If there is a fill prefix and/or a `left-margin', insert them on the
     new line if the line would have been blank. With arg N, insert N
     newlines."
       (interactive "*p")
       (let* ((do-fill-prefix (and fill-prefix (bolp)))
              (do-left-margin (and (bolp) (> (current-left-margin) 0)))
              (loc (point-marker))
              ;; Don't expand an abbrev before point.
              (abbrev-mode nil))
         (delete-horizontal-space t)
         (newline n)
         (indent-according-to-mode)
         (when (eolp)
           (delete-horizontal-space t))
         (goto-char loc)
         (while (> n 0)
           (cond ((bolp)
                  (if do-left-margin (indent-to (current-left-margin)))
                  (if do-fill-prefix (insert-and-inherit fill-prefix))))
           (forward-line 1)
           (setq n (1- n)))
         (goto-char loc)
         (end-of-line)
         (indent-according-to-mode)))

     (global-set-key (kbd "C-o") 'jcf/open-line-with-reindent)
   #+END_SRC
** Randomise lines
   #+BEGIN_SRC emacs-lisp
     (defun sort-lines-random (beg end)
       "Sort lines in region randomly."
       (interactive "r")
       (save-excursion
         (save-restriction
           (narrow-to-region beg end)
           (goto-char (point-min))
           (let ;; To make `end-of-line' and etc. to ignore fields.
               ((inhibit-field-text-motion t))
             (sort-subr nil 'forward-line 'end-of-line nil nil
                        (lambda (s1 s2) (eq (random 2) 0)))))))
   #+END_SRC
** ~isearch~ improvements
   There are a number of ~isearch~ improvements provided. As we're
   typically using ~evil-mode~ and ~evil-search-forward~ they're not
   particuarly useful but are kept around for posterity sake and in
   case we're stuck in Emacs mode.
*** Show number of matches
    #+BEGIN_SRC emacs-lisp
      (when (>= emacs-major-version 24)
        (require-package 'anzu)
        (global-anzu-mode t)
        (diminish 'anzu-mode)
        (global-set-key [remap query-replace-regexp] 'anzu-query-replace-regexp)
        (global-set-key [remap query-replace] 'anzu-query-replace))
    #+END_SRC
*** Use ~occur~ inside ~isearch~
    #+BEGIN_SRC emacs-lisp
      (define-key isearch-mode-map (kbd "C-o") 'isearch-occur)
    #+END_SRC
*** Search back/forth for symbol at point
    #+BEGIN_SRC emacs-lisp
      (defun isearch-yank-symbol ()
        "*Put symbol at current point into search string."
        (interactive)
        (let ((sym (symbol-at-point)))
          (if sym
              (progn
                (setq isearch-regexp t
                      isearch-string (concat "\\_<" (regexp-quote (symbol-name sym)) "\\_>")
                      isearch-message (mapconcat 'isearch-text-char-description isearch-string "")
                      isearch-yank-flag t))
            (ding)))
        (isearch-search-and-update))

      (define-key isearch-mode-map "\C-\M-w" 'isearch-yank-symbol)
    #+END_SRC
*** Zap to isearch
    http://www.emacswiki.org/emacs/ZapToISearch

    #+BEGIN_SRC emacs-lisp
      (defun zap-to-isearch (rbeg rend)
        "Kill the region between the mark and the closest portion of the
      isearch match string. The behaviour is meant to be analogous to
      zap-to-char; let's call it zap-to-isearch.

      The deleted region does not include the isearch word. This is meant to
      be bound only in isearch mode. The point of this function is that
      oftentimes you want to delete some portion of text, one end of which
      happens to be an active isearch word.

      The observation to make is that if you use isearch a lot to move the
      cursor around (as you should, it is much more efficient than using the
      arrows), it happens a lot that you could just delete the active region
      between the mark and the point, not include the isearch word."
        (interactive "r")
        (when (not mark-active)
          (error "Mark is not active"))
        (let* ((isearch-bounds (list isearch-other-end (point)))
               (ismin (apply 'min isearch-bounds))
               (ismax (apply 'max isearch-bounds))
               )
          (if (< (mark) ismin)
              (kill-region (mark) ismin)
            (if (> (mark) ismax)
                (kill-region ismax (mark))
              (error "Internal error in isearch kill function.")))
          (isearch-exit)
          ))

      (define-key isearch-mode-map [(meta z)] 'zap-to-isearch)

      (defun isearch-exit-other-end (rbeg rend)
        "Exit isearch, but at the other end of the search string.
      This is useful when followed by an immediate kill."
        (interactive "r")
        (isearch-exit)
        (goto-char isearch-other-end))

      (define-key isearch-mode-map [(control return)] 'isearch-exit-other-end)
    #+END_SRC
** ~ibuffer~
*** Go fullframe
    #+BEGIN_SRC emacs-lisp
      (require-package 'fullframe)
      (after-load 'ibuffer
       (fullframe ibuffer ibuffer-quit))
    #+END_SRC
*** Version-control support
    Explicitly require ~ibuffer-vc~ to get its column definitions,
    as they can't be autoloaded.

    #+BEGIN_SRC emacs-lisp
      (require-package 'ibuffer-vc)
      (after-load 'ibuffer
        (require 'ibuffer-vc))
    #+END_SRC
*** Filters
    #+BEGIN_SRC emacs-lisp
      (defun ibuffer-set-up-preferred-filters ()
        (ibuffer-vc-set-filter-groups-by-vc-root)
        (unless (eq ibuffer-sorting-mode 'filename/process)
          (ibuffer-do-sort-by-filename/process)))

      (add-hook 'ibuffer-hook 'ibuffer-set-up-preferred-filters)
    #+END_SRC
*** Human readable file sizes
    #+BEGIN_SRC emacs-lisp
      (after-load 'ibuffer
        (define-ibuffer-column size-h
          (:name "Size" :inline t)
          (cond
           ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
           ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
           (t (format "%8d" (buffer-size))))))
    #+END_SRC
*** ~ibuffer-formats~
    Toggle with ~`~.

    #+BEGIN_SRC emacs-lisp
      (setq ibuffer-formats
            '((mark modified read-only vc-status-mini " "
                    (name 18 18 :left :elide)
                    " "
                    (size-h 9 -1 :right)
                    " "
                    (mode 16 16 :left :elide)
                    " "
                    filename-and-process)
              (mark modified read-only vc-status-mini " "
                    (name 18 18 :left :elide)
                    " "
                    (size-h 9 -1 :right)
                    " "
                    (mode 16 16 :left :elide)
                    " "
                    (vc-status 16 16 :left)
                    " "
                    filename-and-process)))

      (setq ibuffer-filter-group-name-face 'font-lock-doc-face)
    #+END_SRC
*** Global keybinding
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-x C-b") 'ibuffer)
    #+END_SRC
** flycheck
*** Emacs 23 support
    #+BEGIN_SRC emacs-lisp
      (when (eval-when-compile (>= emacs-major-version 24))
        (require-package 'flycheck)
        (add-hook 'after-init-hook 'global-flycheck-mode))
    #+END_SRC
*** Override default triggers
    #+BEGIN_SRC emacs-lisp
      (setq flycheck-check-syntax-automatically '(save idle-change mode-enabled)
            flycheck-idle-change-delay 0.8)
    #+END_SRC
** Spelling
   #+BEGIN_SRC emacs-lisp
     (require 'ispell)

     (when (executable-find ispell-program-name)
       (if (fboundp 'prog-mode)
           (add-hook 'prog-mode-hook 'flyspell-prog-mode)
         (dolist (hook '(lisp-mode-hook
                         emacs-lisp-mode-hook
                         scheme-mode-hook
                         clojure-mode-hook
                         ruby-mode-hook
                         yaml-mode
                         python-mode-hook
                         shell-mode-hook
                         php-mode-hook
                         css-mode-hook
                         haskell-mode-hook
                         caml-mode-hook
                         nxml-mode-hook
                         crontab-mode-hook
                         perl-mode-hook
                         tcl-mode-hook
                         javascript-mode-hook))
           (add-hook hook 'flyspell-prog-mode)))

       (after-load 'flyspell
         (add-to-list 'flyspell-prog-text-faces 'nxml-text-face)))
   #+END_SRC
** Multiple major modes
   #+BEGIN_SRC emacs-lisp
     (require-package 'mmm-mode)
     (require 'mmm-auto)
     (setq mmm-global-mode 'buffers-with-submode-classes)
     (setq mmm-submode-decoration-level 0)
   #+END_SRC
** goto-address
   Converts URLs in comments into clickable links.

   #+BEGIN_SRC emacs-lisp
     (setq goto-address-mail-face 'link)

     (dolist (hook (if (fboundp 'prog-mode)
                       '(prog-mode-hook ruby-mode-hook)
                     '(find-file-hooks)))
       (add-hook hook 'goto-address-prog-mode))
  #+END_SRC
** Make scripts executable
   #+BEGIN_SRC emacs-lisp
     (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
   #+END_SRC
** Perl-style regular expressions
   #+BEGIN_SRC emacs-lisp
     (setq-default regex-tool-backend 'perl)
   #+END_SRC
* Sessions
** Setup Desktop
  #+BEGIN_SRC emacs-lisp
    (setq desktop-path (list user-emacs-directory)
          desktop-auto-save-timeout 600)
    (desktop-save-mode 1)
    (defadvice desktop-read (around trace-desktop-errors activate)
      (let ((debug-on-error t))
        ad-do-it))

    (defadvice desktop-read (around time-restore activate)
        (let ((start-time (current-time)))
          (prog1
              ad-do-it
            (message "Desktop restored in %.2fms"
                     (jcf/time-subtract-millis (current-time)
                                                     start-time)))))

    (defadvice desktop-create-buffer (around time-create activate)
      (let ((start-time (current-time))
            (filename (ad-get-arg 1)))
        (prog1
            ad-do-it
          (message "Desktop: %.2fms to restore %s"
                   (jcf/time-subtract-millis (current-time)
                                                   start-time)
                   (when filename
                     (abbreviate-file-name filename))))))
  #+END_SRC
** Restore histories and registers after saving
  #+BEGIN_SRC emacs-lisp
    (setq-default history-length 1000)
    (savehist-mode t)

    (require-package 'session)

    (setq session-save-file (expand-file-name ".session" user-emacs-directory))
    (add-hook 'after-init-hook 'session-initialize)
  #+END_SRC
** Variables to save
   #+BEGIN_SRC emacs-lis
    (setq desktop-globals-to-save
          (append '((comint-input-ring        . 50)
                    (compile-history          . 30)
                    desktop-missing-file-warning
                    (dired-regexp-history     . 20)
                    (extended-command-history . 30)
                    (face-name-history        . 20)
                    (file-name-history        . 100)
                    (grep-find-history        . 30)
                    (grep-history             . 30)
                    (ido-buffer-history       . 100)
                    (ido-last-directory-list  . 100)
                    (ido-work-directory-list  . 100)
                    (ido-work-file-list       . 100)
                    (magit-read-rev-history   . 50)
                    (minibuffer-history       . 50)
                    (org-clock-history        . 50)
                    (org-refile-history       . 50)
                    (org-tags-history         . 50)
                    (query-replace-history    . 60)
                    (read-expression-history  . 60)
                    (regexp-history           . 60)
                    (regexp-search-ring       . 20)
                    register-alist
                    (search-ring              . 20)
                    (shell-command-history    . 50)
                    tags-file-name
                    tags-table-list)))
   #+END_SRC
** Restore frame for Emacs 24 up to 24.3.50
   #+BEGIN_SRC emacs-lisp
     (when (eval-when-compile (and (>= emacs-major-version 24)
                                   (string< emacs-version "24.3.50")))
       (unless (boundp 'desktop-restore-frames)
         (require-package 'frame-restore)
         (frame-restore)))
  #+END_SRC
* Dired
  #+BEGIN_SRC emacs-lisp
    (require-package 'dired+)

    (setq diredp-hide-details-initially-flag nil)

    (after-load 'dired
    (require 'dired+)
    (when (fboundp 'global-dired-hide-details-mode)
    (global-dired-hide-details-mode -1))
    (setq dired-recursive-deletes 'top)
    (define-key dired-mode-map [mouse-2] 'dired-find-file)
    (add-hook 'dired-mode-hook
              (lambda () (guide-key/add-local-guide-key-sequence "%"))))
  #+END_SRC
* Interactively Do Things
  #+BEGIN_SRC emacs-lisp
    (require-package 'ido-vertical-mode)

    (require 'ido)
    (ido-mode t)
    (ido-everywhere t)
    (ido-vertical-mode 1)
    (setq ido-enable-flex-matching t)
    (setq ido-use-filename-at-point nil)
    (setq ido-auto-merge-work-directories-length 0)
    (setq ido-use-virtual-buffers t)

    (when (eval-when-compile (>= emacs-major-version 24))
     (require-package 'ido-ubiquitous)
     (ido-ubiquitous-mode t))

    ;; Use smex to handle M-x
    (when (eval-when-compile (>= emacs-major-version 24))
      (require-package 'smex)
      ;; Change path for ~/.smex-items
      (setq smex-save-file (expand-file-name ".smex-items" user-emacs-directory))
      (global-set-key [remap execute-extended-command] 'smex))

    (require-package 'idomenu)

    ;; Allow the same buffer to be open in different frames
    (setq ido-default-buffer-method 'selected-window)

    ;; http://www.reddit.com/r/emacs/comments/21a4p9/use_recentf_and_ido_together/cgbprem
    (add-hook 'ido-setup-hook (lambda () (define-key ido-completion-map [up] 'previous-history-element)))
  #+END_SRC
* SmartParens
  #+BEGIN_SRC emacs-lisp
    (require-package 'smartparens)

    ;; I don't need paredit, but some package developers do!
    (require-package 'paredit)

    (after-load 'smartparens
      (require 'paredit)
      (disable-paredit-mode))

    ;; Enable smartparens everywhere
    (require 'smartparens-config)

    (setq smartparens-strict-mode t)
    (setq sp-autoinsert-if-followed-by-word t)
    (setq sp-autoskip-closing-pair 'always)
    (setq sp-base-key-bindings 'paredit)
    (setq sp-hybrid-kill-entire-symbol nil)

    (smartparens-global-mode 1)
    (show-smartparens-global-mode +1)

    (sp-use-paredit-bindings)

    (sp-with-modes '(markdown-mode gfm-mode rst-mode)
      (sp-local-pair "*" "*" :bind "C-*")
      (sp-local-tag "2" "**" "**")
      (sp-local-tag "s" "```scheme" "```")
      (sp-local-tag "<"  "<_>" "</_>" :transform 'sp-match-sgml-tags))

    (sp-with-modes '(html-mode sgml-mode)
      (sp-local-pair "<" ">"))

    ;; Close a backtick with another backtick in clojure-mode
    (sp-local-pair 'clojure-mode "`" "`" :when '(sp-in-string-p))

    (sp-local-pair 'emacs-lisp-mode "`" nil :when '(sp-in-string-p))
  #+END_SRC
* Tags
  Powered by [[http://www.gnu.org/software/global/][GNU Global]].

  #+BEGIN_SRC emacs-lisp
    (require-package 'ggtags)
    (ggtags-mode 1)
  #+END_SRC
* Projectile
   #+BEGIN_SRC emacs-lisp
     (require-package 'projectile)
     (projectile-global-mode)
   #+END_SRC
* Hippie
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "M-/") 'hippie-expand)

    (setq hippie-expand-try-functions-list
          '(try-complete-file-name-partially
            try-complete-file-name
            try-expand-dabbrev
            try-expand-dabbrev-all-buffers
            try-expand-dabbrev-from-kill))
  #+END_SRC
* Company
  #+BEGIN_SRC emacs-lisp
    (require-package 'company)
    (add-hook 'after-init-hook 'global-company-mode)

    (defvar jcf/completion-backends
      '(company-go company-inf-ruby company-tern))

    (dolist (package jcf/completion-backends)
      (require-package package))

    (after-load 'company
      (diminish 'company-mode)

      ;; Add completion backends
      (dolist (backend jcf/completion-backends)
        (add-to-list 'company-backends backend)))
  #+END_SRC
* Yasnippet
  #+BEGIN_SRC emacs-lisp
    (require-package 'yasnippet)
    (require-package 'string-utils)

    (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
    (yas-global-mode 1)
  #+END_SRC
* Smart mode line
  Disabled for now.

  #+BEGIN_SRC emacs-lisp
    ;; (require-package 'smart-mode-line)

    ;; (setq sml/theme nil)
    ;; (sml/setup)
  #+END_SRC
* Window management
** Winner
   #+BEGIN_SRC emacs-lisp
     (winner-mode 1)
   #+END_SRC
** Prompt for target window
   Make ~C-x o~ prompt for a target window when there are more than
   two.

   #+BEGIN_SRC emacs-lisp
     (require-package 'switch-window)
     (require 'switch-window)
     (setq switch-window-shortcut-style 'alphabet)
     (global-set-key (kbd "C-x o") 'switch-window)
   #+END_SRC
** Show other buffer when splitting
   When splitting window, show (other-buffer) in the new window.

   #+BEGIN_SRC emacs-lisp
     (defun split-window-func-with-other-buffer (split-function)
       (lexical-let ((s-f split-function))
         (lambda ()
           (interactive)
           (funcall s-f)
           (set-window-buffer (next-window) (other-buffer)))))

     (global-set-key "\C-x2" (split-window-func-with-other-buffer 'split-window-vertically))
     (global-set-key "\C-x3" (split-window-func-with-other-buffer 'split-window-horizontally))
   #+END_SRC
** Rearrange split windows
   #+BEGIN_SRC emacs-lisp
     (defun split-window-horizontally-instead ()
       (interactive)
       (save-excursion
         (delete-other-windows)
         (funcall (split-window-func-with-other-buffer 'split-window-horizontally))))

     (defun split-window-vertically-instead ()
       (interactive)
       (save-excursion
         (delete-other-windows)
         (funcall (split-window-func-with-other-buffer 'split-window-vertically))))

     (global-set-key "\C-x|" 'split-window-horizontally-instead)
     (global-set-key "\C-x_" 'split-window-vertically-instead)

     ;; Borrowed from http://postmomentum.ch/blog/201304/blog-on-emacs
     (defun jcf/split-window ()
       "Split the window to see the most recent buffer in the other window.
     Call a second time to restore the original window configuration."
       (interactive)
       (if (eq last-command 'jcf/split-window)
           (progn
             (jump-to-register :jcf/split-window)
             (setq this-command 'jcf/unsplit-window))
         (window-configuration-to-register :jcf/split-window)
         (switch-to-buffer-other-window nil)))

     (global-set-key (kbd "<f7>") 'jcf/split-window)
     (global-set-key (kbd "<f6>")
                     (lambda ()
                       (interactive)
                       (switch-to-buffer nil)))
   #+END_SRC
* Version Control
** diff-hl
   #+BEGIN_SRC emacs-lisp
     (require-package 'diff-hl)
     (add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
     (add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode)
   #+END_SRC
** Git
*** Setup Magit
   #+BEGIN_SRC emacs-lisp
     (require-package 'magit)
     (require-package 'git-blame)
     (require-package 'git-commit-mode)
     (require-package 'git-rebase-mode)
     (require-package 'gitignore-mode)
     (require-package 'gitconfig-mode)
     (require-package 'git-messenger)

     (setq-default
      magit-save-some-buffers nil
      magit-process-popup-time 10
      magit-diff-refine-hunk t
      magit-completing-read-function 'magit-ido-completing-read)

     (after-load 'magit
       (diminish 'magit-auto-revert-mode))
    #+END_SRC
*** Emacs-style magit-status binding
    #+BEGIN_SRC emacs-lisp
     ;; Hint: customize `magit-repo-dirs' so that you can use C-u M-F12 to
     ;; quickly open magit on any one of your projects.
     (global-set-key [(meta f12)] 'magit-status)
    #+END_SRC
*** Go to parent section binding
    #+BEGIN_SRC emacs-lisp
     (after-load 'magit
       (define-key magit-status-mode-map (kbd "C-M-<up>") 'magit-goto-parent-section))
    #+END_SRC
*** Fullframe
    #+BEGIN_SRC emacs-lisp
     (require-package 'fullframe)
     (after-load 'magit
       (fullframe magit-status magit-mode-quit-window))
    #+END_SRC
*** ~git-wip~
    Disabled because I found it irritating.

    #+BEGIN_SRC emacs-lisp
     ;; (after-load 'magit
     ;;   (global-magit-wip-save-mode)
     ;;   (diminish 'magit-wip-save-mode))
    #+END_SRC
*** Disable ~command-h~ on OS X
    #+BEGIN_SRC emacs-lisp
     (when *is-a-mac*
       (after-load 'magit
         (add-hook 'magit-mode-hook (lambda () (local-unset-key [(meta h)])))))
    #+END_SRC
*** ~git-grep~ binding
    #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x v f") 'vc-git-grep)
    #+END_SRC
*** Subversion support (~git-svn~)
    #+BEGIN_SRC emacs-lisp
      (require-package 'magit-svn)
      (autoload 'magit-svn-enabled "magit-svn")

      (defun jcf/maybe-enable-magit-svn-mode ()
        (when (magit-svn-enabled)
          (magit-svn-mode)))

      (add-hook 'magit-status-mode-hook #'jcf/maybe-enable-magit-svn-mode)

      (after-load 'compile
        (dolist
            (defn (list '(git-svn-updated "^\t[A-Z]\t\\(.*\\)$" 1 nil nil 0 1)
                        '(git-svn-needs-update "^\\(.*\\): needs update$" 1 nil nil 2 1)))
          (add-to-list 'compilation-error-regexp-alist-alist defn)
          (add-to-list 'compilation-error-regexp-alist (car defn))))

      (defvar git-svn--available-commands nil "Cached list of git svn subcommands")

      (defun git-svn (dir)
        "Run a git svn subcommand in DIR."
        (interactive "DSelect directory: ")
        (unless git-svn--available-commands
          (setq git-svn--available-commands
                (jcf/string-all-matches
                 "^  \\([a-z\\-]+\\) +"
                 (shell-command-to-string "git svn help") 1)))
        (let* ((default-directory (vc-git-root dir))
               (compilation-buffer-name-function (lambda (major-mode-name) "*git-svn*")))
          (compile (concat "git svn "
                           (ido-completing-read "git-svn command: "
                                                git-svn--available-commands nil t)))))
    #+END_SRC
*** TODO Messenger - explain what this is for
    #+BEGIN_SRC emacs-lisp
     (require-package 'git-messenger)
     (global-set-key (kbd "C-x v p") #'git-messenger:popup-message)
    #+END_SRC
*** GitHub
    #+BEGIN_SRC emacs-lisp
     (require-package 'gh)
     (require-package 'yagist)
     (require-package 'github-browse-file)
     (require-package 'bug-reference-github)
     (add-hook 'prog-mode-hook 'bug-reference-prog-mode)
   #+END_SRC
** Darcs
   #+BEGIN_SRC emacs-lisp
     (require-package 'darcsum)
     (require-package 'vc-darcs)

     (add-to-list 'vc-handled-backends 'DARCS)
     (autoload 'vc-darcs-find-file-hook "vc-darcs")
     (add-hook 'find-file-hooks 'vc-darcs-find-file-hook)

     (setq darcsum-whatsnew-switches "-l")
   #+END_SRC
* The Silver Surfer (~ag~)
  A [[https://github.com/ggreer/the_silver_searcher][code searching tool]] similar to ack, with a focus on speed.

  Can be [[https://github.com/ggreer/the_silver_searcher#installation][installed]] via Homebrew on OS X.

  #+BEGIN_SRC emacs-lisp
    (when (executable-find "ag")
      (require-package 'ag)
      (require-package 'wgrep-ag)
      (setq-default ag-highlight-search t)
      (global-set-key (kbd "M-?") 'ag-project))
  #+END_SRC
** Highlight escape sequences
   #+BEGIN_SRC emacs-lisp
     (require-package 'highlight-escape-sequences)
     (hes-mode)
   #+END_SRC
** Guide key
   #+BEGIN_SRC emacs-lisp
     (require-package 'guide-key)
     (setq guide-key/guide-key-sequence
           '("C-x r"
             "C-x 4"
             "C-x 5"
             "C-c ;"
             "C-c ; f"
             "C-c ' f"
             "C-x n"))
     (guide-key-mode 1)
     (diminish 'guide-key-mode)
   #+END_SRC
** Editorconfig
   #+BEGIN_SRC emacs-lisp
     (require-package 'editorconfig)
     (add-to-list 'auto-mode-alist '("\\.editorconfig\\'" . conf-unix-mode))
   #+END_SRC
** recentf
   #+BEGIN_SRC emacs-lisp
     (recentf-mode 1)
     (setq recentf-max-saved-items 1000
           recentf-exclude '("/tmp/" "/ssh:"))
    #+END_SRC
* Org mode
** Basics
   #+BEGIN_SRC emacs-lisp
     (when (< emacs-major-version 24)
       (require-package 'org))
     (require-package 'org-fstree)
     (when *is-a-mac*
       (require-package 'org-mac-link)
       (autoload 'org-mac-grab-link "org-mac-link" nil t)
       (require-package 'org-mac-iCal))


     (define-key global-map (kbd "C-c l") 'org-store-link)
     (define-key global-map (kbd "C-c a") 'org-agenda)

     ;; Various preferences
     (setq org-log-done t
           org-completion-use-ido t
           org-edit-timestamp-down-means-later t
           org-agenda-start-on-weekday nil
           org-agenda-span 14
           org-agenda-include-diary t
           org-agenda-window-setup 'current-window
           org-fast-tag-selection-single-key 'expert
           org-export-kill-product-buffer-when-displayed t
           org-tags-column 80)

     ;; Syntax highlight inline code blocks
     (setq org-src-fontify-natively t)

     ;; Where to keep org files
     (setq org-directory "~/Dropbox/Org"
           org-agenda-files '("~/Dropbox/Org/")
           org-default-notes-file "~/Dropbox/Org/refile.org")

     ; Refile targets include this file and any file contributing to the agenda - up to 5 levels deep
     (setq org-refile-targets (quote ((nil :maxlevel . 5) (org-agenda-files :maxlevel . 5))))
     ; Targets start with the file name - allows creating level 1 tasks
     (setq org-refile-use-outline-path (quote file))
     ; Targets complete in steps so we start with filename, TAB shows the next level of targets etc
     (setq org-outline-path-complete-in-steps t)


     (setq org-todo-keywords
           (quote ((sequence "TODO(t)" "STARTED(s)" "|" "DONE(d!/!)")
                   (sequence "WAITING(w@/!)" "SOMEDAY(S)" "|" "CANCELLED(c@/!)"))))
   #+END_SRC
** Org clock
   #+BEGIN_SRC emacs-lisp
     ;; Save the running clock and all clock history when exiting Emacs, load it on startup
     (setq org-clock-persistence-insinuate t)
     (setq org-clock-persist t)
     (setq org-clock-in-resume t)

     ;; Change task state to STARTED when clocking in
     (setq org-clock-in-switch-to-state "STARTED")
     ;; Save clock data and notes in the LOGBOOK drawer
     (setq org-clock-into-drawer t)
     ;; Removes clocked tasks with 0:00 duration
     (setq org-clock-out-remove-zero-time-clocks t)

     ;; Show clock sums as hours and minutes, not "n days" etc.
     (setq org-time-clocksum-format
           '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))

     ;; Show the clocked-in task - if any - in the header line
     (defun jcf/show-org-clock-in-header-line ()
       (setq-default header-line-format '((" " org-mode-line-string " "))))

     (defun jcf/hide-org-clock-from-header-line ()
       (setq-default header-line-format nil))

     (add-hook 'org-clock-in-hook 'jcf/show-org-clock-in-header-line)
     (add-hook 'org-clock-out-hook 'jcf/hide-org-clock-from-header-line)
     (add-hook 'org-clock-cancel-hook 'jcf/hide-org-clock-from-header-line)

     (after-load 'org-clock
       (define-key org-clock-mode-line-map [header-line mouse-2] 'org-clock-goto)
       (define-key org-clock-mode-line-map [header-line mouse-1] 'org-clock-menu))
   #+END_SRC
** Pomodoro
   #+BEGIN_SRC emacs-lisp
     (require-package 'org-pomodoro)
     (after-load 'org-agenda
       (define-key org-agenda-mode-map (kbd "P") 'org-pomodoro))
   #+END_SRC
** iCal in agenda
   Disabled for now.

   #+BEGIN_SRC emacs-lisp
     ;; (when (and *is-a-mac* (require 'org-mac-iCal nil t))
     ;;   (setq org-agenda-include-diary t
     ;;         org-agenda-custom-commands
     ;;         '(("I" "Import diary from iCal" agenda ""
     ;;            ((org-agenda-mode-hook #'org-mac-iCal)))))

     ;;   (add-hook 'org-agenda-cleanup-fancy-diary-hook
     ;;             (lambda ()
     ;;               (goto-char (point-min))
     ;;               (save-excursion
     ;;                 (while (re-search-forward "^[a-z]" nil t)
     ;;                   (goto-char (match-beginning 0))
     ;;                   (insert "0:00-24:00 ")))
     ;;               (while (re-search-forward "^ [a-z]" nil t)
     ;;                 (goto-char (match-beginning 0))
     ;;                 (save-excursion
     ;;                   (re-search-backward "^[0-9]+:[0-9]+-[0-9]+:[0-9]+ " nil t))
     ;;                 (insert (match-string 0))))))
   #+END_SRC
** Bindings
   #+BEGIN_SRC emacs-lisp
     (after-load 'org
       (define-key org-mode-map (kbd "C-M-<up>") 'org-up-element)
       (when *is-a-mac*
         (define-key org-mode-map (kbd "M-h") nil))
       (define-key org-mode-map (kbd "C-M-<up>") 'org-up-element)
       (when *is-a-mac*
         (define-key org-mode-map (kbd "C-c g") 'org-mac-grab-link)))
  #+END_SRC
* Utilities
** eshell
   Always insert text at the prompt.

   #+BEGIN_SRC emacs-lisp
     (setq eshell-scroll-to-bottom-on-input 'all)
   #+END_SRC

   Allow symbol names to be used for redirection targets.

   #+BEGIN_SRC emacs-lisp
     (setq eshell-buffer-shorthand t)
   #+END_SRC

   This makes it possible to redirect output like so:

   #+BEGIN_SRC shell-script
     echo hello > '*scratch*
   #+END_SRC

   Ignore case when completing filenames.

   #+BEGIN_SRC emacs-lisp
     (setq eshell-cmpl-ignore-case t)
   #+END_SRC

   Error when a glob matches nothing. This mirrors the default
   behaviour of zsh.

   #+BEGIN_SRC emacs-lisp
     (setq eshell-error-if-no-glob t)
   #+END_SRC

   Make globs case-insensitive.

   #+BEGIN_SRC emacs-lisp
     (setq eshell-glob-case-insensitive t)
   #+END_SRC
** erc
   #+BEGIN_SRC emacs-lisp
     (after-load 'erc
       (setq erc-hide-list '("JOIN" "PART" "QUIT"))

       (setq erc-timestamp-only-if-changed-flag nil)
       (setq erc-timestamp-format "[%H:%M] ")
       (setq erc-insert-timestamp-function 'erc-insert-timestamp-left)

       (setq erc-truncate-mode t)

       (add-hook 'window-configuration-change-hook
                 (lambda ()
                   (setq erc-fill-column (- (window-width) 2)))))
    #+END_SRC
** Dash
   #+BEGIN_SRC emacs-lisp
     ;; Support for the http://kapeli.com/dash documentation browser

     (defun jcf/dash-installed-p ()
       "Return t if Dash is installed on this machine, or nil otherwise."
       (let ((lsregister "/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister"))
         (and (file-executable-p lsregister)
              (not (string-equal
                    ""
                    (shell-command-to-string
                     (concat lsregister " -dump|grep com.kapeli.dash")))))))

     (when (and *is-a-mac* (not (package-installed-p 'dash-at-point)))
       (message "Checking whether Dash is installed")
       (when (jcf/dash-installed-p)
         (require-package 'dash-at-point)))

     (when (package-installed-p 'dash-at-point)
       (global-set-key (kbd "C-c D") 'dash-at-point))
   #+END_SRC
* Languages
** Clojure
   #+BEGIN_SRC emacs-lisp
     (require-package 'clojure-mode)
     (require-package 'clj-refactor)
     (require-package 'clojure-test-mode)
     (require-package 'cljsbuild-mode)
     (require-package 'elein)
     (require-package 'typed-clojure-mode)

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; Slime with Clojure
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     (defun slime-clojure-repl-setup ()
       "Some REPL setup additional to that in durendal."
       (when (string-equal (slime-lisp-implementation-name) "clojure")
         (when (slime-inferior-process)
           (message "Setting up repl for clojure")
           (slime-redirect-inferior-output))

         (set-syntax-table clojure-mode-syntax-table)
         (setq lisp-indent-function 'clojure-indent-function)
         (let (font-lock-mode)
           (clojure-mode-font-lock-setup))))

     (after-load 'slime-repl
       (add-hook 'slime-repl-mode-hook 'slime-clojure-repl-setup))



     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     ;; Misc clojure tweaks
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

     (after-load 'clojure-mode
       (add-hook 'clojure-mode-hook 'jcf/lisp-setup)
       ;; Undo activation of Paredit by clojure-mode
       (add-hook 'clojure-mode-hook (lambda () (disable-paredit-mode)))
       (add-hook 'clojure-mode-hook (lambda () (clj-refactor-mode 1)))
       (add-hook 'clojure-mode-hook 'typed-clojure-mode)
       (add-hook 'clojure-mode-hook 'subword-mode))

     

     ;; Use clojure-mode for clojurescript, since clojurescript-mode
     ;; pulls in Slime
     (add-auto-mode 'clojure-mode "\\.cljs\\'")
   #+END_SRC
*** Cider
    #+BEGIN_SRC emacs-lisp
      (require-package 'emacs '(24))

      (require-package 'cider)
      (require-package 'slamhound)

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; nrepl with Clojure
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

      (setq nrepl-popup-stacktraces nil)

      (after-load 'cider
        (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
        (add-hook 'cider-repl-mode-hook 'subword-mode)

        ;; nrepl isn't based on comint
        (add-hook 'cider-repl-mode-hook
                  (lambda () (setq show-trailing-whitespace nil))))
    #+END_SRC
** Common-Lisp
   #+BEGIN_SRC emacs-lisp
     ;; See http://bc.tech.coop/blog/070927.html
     (add-auto-mode 'lisp-mode "\\.cl\\'")
     (add-hook 'lisp-mode-hook (lambda ()
                                 (unless (featurep 'slime)
                                   (require 'slime)
                                   (normal-mode))))

     (after-load 'slime
       (when (executable-find "sbcl")
         (add-to-list 'slime-lisp-implementations
                      '(sbcl ("sbcl") :coding-system utf-8-unix)))
       (when (executable-find "lisp")
         (add-to-list 'slime-lisp-implementations
                      '(cmucl ("lisp") :coding-system iso-latin-1-unix))))

     ;; From http://bc.tech.coop/blog/070515.html
     (defun lispdoc ()
       "Searches lispdoc.com for SYMBOL, which is by default the symbol currently under the curser"
       (interactive)
       (let* ((word-at-point (word-at-point))
              (symbol-at-point (symbol-at-point))
              (default (symbol-name symbol-at-point))
              (inp (read-from-minibuffer
                    (if (or word-at-point symbol-at-point)
                        (concat "Symbol (default " default "): ")
                      "Symbol (no default): "))))
         (if (and (string= inp "") (not word-at-point) (not
                                                        symbol-at-point))
             (message "you didn't enter a symbol!")
           (let ((search-type (read-from-minibuffer
                               "full-text (f) or basic (b) search (default b)? ")))
             (browse-url (concat "http://lispdoc.com?q="
                                 (if (string= inp "")
                                     default
                                   inp)
                                 "&search="
                                 (if (string-equal search-type "f")
                                     "full+text+search"
                                   "basic+search")))))))

     (define-key lisp-mode-map (kbd "C-c l") 'lispdoc)
   #+END_SRC
** Configuration
   Use conf-mode for [[https://github.com/ddollar/foreman][Foreman]] Procfiles.

   #+BEGIN_SRC emacs-lisp
     (add-auto-mode 'conf-mode "Procfile")
   #+END_SRC
** Crontab
   #+BEGIN_SRC emacs-lisp
     (require-package 'crontab-mode)
     (add-auto-mode 'crontab-mode "\\.?cron\\(tab\\)?\\'")
   #+END_SRC
** CSS
*** Indentation
   #+BEGIN_SRC emacs-lisp
     (setq css-indent-offset 2)
   #+END_SRC
*** Colourise CSS colour literals
    Note that ~rainbow-mode~ needs ~color.el~, bundled with Emacs
    >= 24.

    #+BEGIN_SRC emacs-lisp
      (when (eval-when-compile (>= emacs-major-version 24))
        (require-package 'rainbow-mode)
        (dolist (hook '(css-mode-hook html-mode-hook sass-mode-hook))
          (add-hook hook 'rainbow-mode)))
    #+END_SRC
*** Embedded CSS support
    #+BEGIN_SRC emacs-lisp
     (require-package 'mmm-mode)

     (after-load 'mmm-vars
       (mmm-add-group
        'html-css
        '((css-cdata
           :submode css-mode
           :face mmm-code-submode-face
           :front "<style[^>]*>[ \t\n]*\\(//\\)?<!\\[CDATA\\[[ \t]*\n?"
           :back "[ \t]*\\(//\\)?]]>[ \t\n]*</style>"
           :insert ((?j js-tag nil @ "<style type=\"text/css\">"
                        @ "\n" _ "\n" @ "</script>" @)))
          (css
           :submode css-mode
           :face mmm-code-submode-face
           :front "<style[^>]*>[ \t]*\n?"
           :back "[ \t]*</style>"
           :insert ((?j js-tag nil @ "<style type=\"text/css\">"
                        @ "\n" _ "\n" @ "</style>" @)))
          (css-inline
           :submode css-mode
           :face mmm-code-submode-face
           :front "style=\""
           :back "\"")))
       (dolist (mode (list 'html-mode 'nxml-mode))
         (mmm-add-mode-ext-class mode "\\.r?html\\(\\.erb\\)?\\'" 'html-css)))
    #+END_SRC
*** SASS & SCSS
    #+BEGIN_SRC emacs-lisp
     (require-package 'sass-mode)
     (require-package 'scss-mode)
     (setq-default scss-compile-at-save nil)
    #+END_SRC
*** LESS
    #+BEGIN_SRC emacs-lisp
     ;;; LESS
     (require-package 'less-css-mode)
     (when (featurep 'js2-mode)
       (require-package 'skewer-less))
    #+END_SRC
*** Use Eldoc for syntax hints
    #+BEGIN_SRC emacs-lisp
      (require-package 'css-eldoc)
      (autoload 'turn-on-css-eldoc "css-eldoc")
      (add-hook 'css-mode-hook 'turn-on-css-eldoc)
    #+END_SRC
** CSV
   #+BEGIN_SRC emacs-lisp
     (require-package 'csv-mode)
     (require-package 'csv-nav)

     (add-auto-mode 'csv-mode "\\.[Cc][Ss][Vv]\\'")

     (setq csv-separators '("," ";" "|" " "))
   #+END_SRC
** Cucumber
   #+BEGIN_SRC emacs-lisp
     (require-package 'feature-mode)
   #+END_SRC
** Erlang
   #+BEGIN_SRC emacs-lisp
     (ignore-errors
       (require-package 'erlang))

     (when (package-installed-p 'erlang)
       (require 'erlang-start))
   #+END_SRC
** Golang
   It is assumed your ~GOPATH~, and ~PATH~ are already setup. If this
   is not the case you can set the relevant environment variables using
   something like:

   #+BEGIN_SRC go
     (setenv "GOPATH" (expand-file-name "Go" (getenv "HOME")))
     (setenv "PATH" (concat (getenv "PATH") ":"
     (expand-file-name "bin" (getenv "GOPATH"))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (require-package 'go-mode)
   #+END_SRC

   Require goflymake if it's installed. This dependency is managed
   outside of Emacs. You can install goflymake like so:

   #+BEGIN_SRC sh
      go get -u github.com/dougm/goflymake
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defvar go-flymake-path
       (expand-file-name "src/github.com/dougm/goflymake" (getenv "GOPATH")))

     (defun jcf-setup-go-flymake ()
       "Add PATH to 'load-path', and require go-flymake."
       (add-to-list 'load-path go-flymake-path)
       (require 'go-flymake))

     (if (file-exists-p go-flymake-path) (jcf-setup-go-flymake))
   #+END_SRC

   Format our code automatically when saving.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'before-save-hook #'gofmt-before-save)
   #+END_SRC
** Haml
   #+BEGIN_SRC emacs-lisp
     (require-package 'haml-mode)

     (after-load 'haml-mode
       (define-key haml-mode-map (kbd "C-o") 'open-line)
       (when (fboundp 'electric-indent-mode)
         (add-hook 'haml-mode-hook (lambda () (electric-indent-mode -1)))))
   #+END_SRC
** Haskell
   #+BEGIN_SRC emacs-lisp
     (require-package 'haskell-mode)

     (when (> emacs-major-version 23)
       (require-package 'flycheck-hdevtools)
       (require-package 'flycheck-haskell))
     (after-load 'flycheck
       (require 'flycheck-hdevtools))

     (dolist (hook '(haskell-mode-hook inferior-haskell-mode-hook))
       (add-hook hook 'turn-on-haskell-doc-mode))

     (add-auto-mode 'haskell-mode "\\.ghci\\'")

     (require-package 'hi2)
     ;;(add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
     (add-hook 'haskell-mode-hook 'turn-on-hi2)

     (add-hook 'haskell-mode-hook (lambda () (subword-mode +1)))

     (setq-default haskell-stylish-on-save t)

     (after-load 'haskell-mode
       (define-key haskell-mode-map (kbd "C-c h") 'hoogle)
       (define-key haskell-mode-map (kbd "C-o") 'open-line))

     (when (eval-when-compile (>= emacs-major-version 24))
       (require-package 'ghci-completion)
       (add-hook 'inferior-haskell-mode-hook 'turn-on-ghci-completion))

     (eval-after-load 'page-break-lines
       '(push 'haskell-mode page-break-lines-modes))

     ;; Make compilation-mode understand "at blah.hs:11:34-50" lines output by GHC
     (after-load 'compile
       (let ((alias 'ghc-at-regexp))
         (add-to-list
          'compilation-error-regexp-alist-alist
          (list alias " at \\(.*\\.\\(?:l?[gh]hs\\|hi\\)\\):\\([0-9]+\\):\\([0-9]+\\)-[0-9]+$" 1 2 3 0 1))
         (add-to-list
          'compilation-error-regexp-alist alias)))
   #+END_SRC
** HTML
   See [[Ruby]] configuration for ERB setup.

   #+BEGIN_SRC emacs-lisp
     (require-package 'tidy)
     (add-hook 'html-mode-hook (lambda () (tidy-build-menu html-mode-map)))

     (require-package 'tagedit)
     (after-load 'sgml-mode
       (tagedit-add-paredit-like-keybindings)
       (add-hook 'sgml-mode-hook (lambda () (tagedit-mode 1))))

     (add-auto-mode 'html-mode "\\.(jsp|tmpl)\\'")
   #+END_SRC
** Javascript
*** Basics
   #+BEGIN_SRC emacs-lisp
     (require-package 'json-mode)
     (when (>= emacs-major-version 24)
       (require-package 'js2-mode)
       (require-package 'coffee-mode)
       (require-package 'jsx-mode))
     (require-package 'js-comint)

     (defcustom preferred-javascript-mode
       (first (remove-if-not #'fboundp '(js2-mode js-mode)))
       "Javascript mode to use for .js files."
       :type 'symbol
       :group 'programming
       :options '(js2-mode js-mode))
     (defvar preferred-javascript-indent-level 2)
    #+END_SRC

   Need to first remove from list if present, since elpa adds entries
   too, which may be in an arbitrary order.

    #+BEGIN_SRC emacs-lisp
     (eval-when-compile (require 'cl))
     (setq auto-mode-alist (cons `("\\.js\\(\\.erb\\)?\\'" . ,preferred-javascript-mode)
                                 (loop for entry in auto-mode-alist
                                       unless (eq preferred-javascript-mode (cdr entry))
                                       collect entry)))
    #+END_SRC
*** ~js2-mode~
    #+BEGIN_SRC emacs-lisp
     (after-load 'js2-mode
       (add-hook 'js2-mode-hook '(lambda () (setq mode-name "JS2"))))

     (setq-default
      js2-basic-offset preferred-javascript-indent-level
      js2-bounce-indent-p nil)

     (after-load 'js2-mode
       (js2-imenu-extras-setup))
    #+END_SRC
*** ~js-mode~
    #+BEGIN_SRC emacs-lisp
     (setq-default js-indent-level preferred-javascript-indent-level)


     (add-to-list 'interpreter-mode-alist (cons "node" preferred-javascript-mode))

     
     ;; Javascript nests {} and () a lot, so I find this helpful

     (require-package 'rainbow-delimiters)
     (dolist (hook '(js2-mode-hook js-mode-hook json-mode-hook))
       (add-hook hook 'rainbow-delimiters-mode))


     
     ;;; Coffeescript

     (after-load 'coffee-mode
       (setq coffee-js-mode preferred-javascript-mode
             coffee-tab-width preferred-javascript-indent-level))

     (when (fboundp 'coffee-mode)
       (add-to-list 'auto-mode-alist '("\\.coffee\\.erb\\'" . coffee-mode)))


     
     ;;; JSX
     (add-auto-mode 'jsx-mode "\\.jsx\\'")

     
     ;;; JSON
     (add-auto-mode 'json-mode "\\.bowerrc\\'" "\\.csslintrc\\'" "\\.jshintrc\\'")


     ;; ---------------------------------------------------------------------------
     ;; Run and interact with an inferior JS via js-comint.el
     ;; ---------------------------------------------------------------------------

     (setq inferior-js-program-command "js")

     (defvar inferior-js-minor-mode-map (make-sparse-keymap))
     (define-key inferior-js-minor-mode-map "\C-x\C-e" 'js-send-last-sexp)
     (define-key inferior-js-minor-mode-map "\C-\M-x" 'js-send-last-sexp-and-go)
     (define-key inferior-js-minor-mode-map "\C-cb" 'js-send-buffer)
     (define-key inferior-js-minor-mode-map "\C-c\C-b" 'js-send-buffer-and-go)
     (define-key inferior-js-minor-mode-map "\C-cl" 'js-load-file-and-go)

     (define-minor-mode inferior-js-keys-mode
       "Bindings for communicating with an inferior js interpreter."
       nil " InfJS" inferior-js-minor-mode-map)

     (dolist (hook '(js2-mode-hook js-mode-hook))
       (add-hook hook 'inferior-js-keys-mode))

     ;; ---------------------------------------------------------------------------
     ;; Alternatively, use skewer-mode
     ;; ---------------------------------------------------------------------------

     (when (and (>= emacs-major-version 24) (featurep 'js2-mode))
       (require-package 'skewer-mode)
       (after-load 'skewer-mode
         (add-hook 'skewer-mode-hook
                   (lambda () (inferior-js-keys-mode -1)))))
   #+END_SRC
** Lisp
   #+BEGIN_SRC emacs-lisp
     (require-package 'elisp-slime-nav)
     (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
       (add-hook hook 'elisp-slime-nav-mode))

     (require-package 'lively)

     (setq-default initial-scratch-message
                   (concat ";; Happy hacking " (or user-login-name "") "!\n\n"))


     
     ;; Make C-x C-e run 'eval-region if the region is active

     (defun jcf/eval-last-sexp-or-region (beg end prefix)
       "Eval region from BEG to END if active, otherwise the last sexp."
       (interactive "r\nP")
       (if (use-region-p)
           (eval-region beg end)
         (pp-eval-last-sexp prefix)))

     (global-set-key (kbd "M-:") 'pp-eval-expression)

     (after-load 'lisp-mode
       (define-key emacs-lisp-mode-map (kbd "C-x C-e") 'jcf/eval-last-sexp-or-region))

     (require-package 'ipretty)
     (ipretty-mode 1)


     ;; ----------------------------------------------------------------------------
     ;; Hippie-expand
     ;; ----------------------------------------------------------------------------

     (defun my/emacs-lisp-module-name ()
       "Search the buffer for `provide' declaration."
       (save-excursion
         (goto-char (point-min))
         (when (search-forward-regexp "^(provide '" nil t)
           (symbol-name (symbol-at-point)))))

     ;; Credit to Chris Done for this one.
     (defun my/try-complete-lisp-symbol-without-namespace (old)
       "Hippie expand \"try\" function which expands \"-foo\" to \"modname-foo\" in elisp."
       (unless old
         (he-init-string (he-lisp-symbol-beg) (point))
         (when (string-prefix-p "-" he-search-string)
           (let ((mod-name (my/emacs-lisp-module-name)))
             (when mod-name
               (setq he-expand-list (list (concat mod-name he-search-string)))))))
       (when he-expand-list
         (he-substitute-string (car he-expand-list))
         (setq he-expand-list nil)
         t))

     (defun set-up-hippie-expand-for-elisp ()
       "Locally set `hippie-expand' completion functions for use with Emacs Lisp."
       (make-local-variable 'hippie-expand-try-functions-list)
       (add-to-list 'hippie-expand-try-functions-list 'try-complete-lisp-symbol t)
       (add-to-list 'hippie-expand-try-functions-list 'try-complete-lisp-symbol-partially t)
       (add-to-list 'hippie-expand-try-functions-list 'my/try-complete-lisp-symbol-without-namespace t))


     ;; ----------------------------------------------------------------------------
     ;; Automatic byte compilation
     ;; ----------------------------------------------------------------------------

     (require-package 'auto-compile)
     (auto-compile-on-save-mode 1)
     (auto-compile-on-load-mode 1)

     ;; ----------------------------------------------------------------------------
     ;; Highlight current sexp
     ;; ----------------------------------------------------------------------------

     (require-package 'hl-sexp)

     ;; Prevent flickery behaviour due to hl-sexp-mode unhighlighting before each command
     (after-load 'hl-sexp
       (defadvice hl-sexp-mode (after unflicker (&optional turn-on) activate)
         (when turn-on
           (remove-hook 'pre-command-hook #'hl-sexp-unhighlight))))


     
     ;;; Support byte-compilation in a sub-process, as
     ;;; required by highlight-cl

     (defun jcf/byte-compile-file-batch (filename)
       "Byte-compile FILENAME in batch mode, ie. a clean sub-process."
       (interactive "fFile to byte-compile in batch mode: ")
       (let ((emacs (car command-line-args)))
         (compile
          (concat
           emacs " "
           (mapconcat
            'shell-quote-argument
            (list "-Q" "-batch" "-f" "batch-byte-compile" filename)
            " ")))))


     ;; ----------------------------------------------------------------------------
     ;; Enable desired features for all lisp modes
     ;; ----------------------------------------------------------------------------
     (require-package 'rainbow-delimiters)
     (require-package 'paredit) ; Redshank requires paredit
     (require-package 'redshank)
     (after-load 'redshank
       (diminish 'redshank-mode))


     (defun jcf/lisp-setup ()
       "Enable features useful in any Lisp mode."
       (turn-on-eldoc-mode)
       (redshank-mode)
       (smartparens-strict-mode +1)
       (rainbow-delimiters-mode +1)
       (disable-paredit-mode))

     (defun jcf/emacs-lisp-setup ()
       "Enable features useful when working with elisp."
       (elisp-slime-nav-mode t)
       (set-up-hippie-expand-for-elisp)
       (disable-paredit-mode))

     (defconst jcf/elispy-modes
       '(emacs-lisp-mode ielm-mode)
       "Major modes relating to elisp.")

     (defconst jcf/lispy-modes
       (append jcf/elispy-modes
               '(lisp-mode inferior-lisp-mode lisp-interaction-mode))
       "All lispy major modes.")

     (require 'derived)

     (dolist (hook (mapcar #'derived-mode-hook-name jcf/lispy-modes))
       (add-hook hook 'jcf/lisp-setup))

     (dolist (hook (mapcar #'derived-mode-hook-name jcf/elispy-modes))
       (add-hook hook 'jcf/emacs-lisp-setup))

     (defun jcf/maybe-check-parens ()
       "Run `check-parens' if this is a lispy mode."
       (when (memq major-mode jcf/lispy-modes)
         (check-parens)))

     (add-hook 'after-save-hook #'jcf/maybe-check-parens)

     (require-package 'eldoc-eval)
     (require 'eldoc-eval)

     (add-to-list 'auto-mode-alist '("\\.emacs-project\\'" . emacs-lisp-mode))
     (add-to-list 'auto-mode-alist '("archive-contents\\'" . emacs-lisp-mode))

     (require-package 'cl-lib-highlight)
     (after-load 'lisp-mode
       (cl-lib-highlight-initialize))

     ;; ----------------------------------------------------------------------------
     ;; Delete .elc files when reverting the .el from VC or magit
     ;; ----------------------------------------------------------------------------

     ;; When .el files are open, we can intercept when they are modified
     ;; by VC or magit in order to remove .elc files that are likely to
     ;; be out of sync.

     ;; This is handy while actively working on elisp files, though
     ;; obviously it doesn't ensure that unopened files will also have
     ;; their .elc counterparts removed - VC hooks would be necessary for
     ;; that.

     (defvar jcf/vc-reverting nil
       "Whether or not VC or Magit is currently reverting buffers.")

     (defadvice revert-buffer (after jcf/maybe-remove-elc activate)
       "If reverting from VC, delete any .elc file that will now be out of sync."
       (when jcf/vc-reverting
         (when (and (eq 'emacs-lisp-mode major-mode)
                    buffer-file-name
                    (string= "el" (file-name-extension buffer-file-name)))
           (let ((elc (concat buffer-file-name "c")))
             (when (file-exists-p elc)
               (message "Removing out-of-sync elc file %s" (file-name-nondirectory elc))
               (delete-file elc))))))

     (defadvice magit-revert-buffers (around jcf/reverting activate)
       (let ((jcf/vc-reverting t))
         ad-do-it))
     (defadvice vc-revert-buffer-internal (around jcf/reverting activate)
       (let ((jcf/vc-reverting t))
         ad-do-it))


     
     (require-package 'macrostep)

     (after-load 'lisp-mode
       (define-key emacs-lisp-mode-map (kbd "C-c e") 'macrostep-expand))

     

     ;; A quick way to jump to the definition of a function given its key binding
     (global-set-key (kbd "C-h K") 'find-function-on-key)
   #+END_SRC
** Lua
   #+BEGIN_SRC emacs-lisp
     (require-package 'lua-mode)
   #+END_SRC
** Markdown
   #+BEGIN_SRC emacs-lisp
     (require-package 'markdown-mode)

     (setq auto-mode-alist
           (cons '("\\.\\(md\\|markdown\\)\\'" . markdown-mode) auto-mode-alist))

     (require-package 'pandoc-mode)

     (after-load 'markdown-mode
       (add-hook 'markdown-mode-hook 'turn-on-pandoc)
       (add-hook 'markdown-mode-hook
                 (lambda () (guide-key/add-local-guide-key-sequence "C-c /"))))
   #+END_SRC
** NXML
   #+BEGIN_SRC emacs-lisp
     (add-auto-mode
      'nxml-mode
      (concat "\\."
              (regexp-opt
               '("xml" "xsd" "sch" "rng" "xslt" "svg" "rss"
                 "gpx" "tcx" "plist"))
              "\\'"))
     (setq magic-mode-alist (cons '("<\\?xml " . nxml-mode) magic-mode-alist))
     (fset 'xml-mode 'nxml-mode)
     (add-hook 'nxml-mode-hook (lambda ()
                                 (set (make-local-variable 'ido-use-filename-at-point) nil)))
     (setq nxml-slash-auto-complete-flag t)
   #+END_SRC
*** Pretty printing
    http://sinewalker.wordpress.com/2008/06/26/pretty-printing-xml-with-emacs-nxml-mode/

    #+BEGIN_SRC emacs-lisp
      (defun jcf/pp-xml-region (begin end)
        "Pretty format XML markup in region. The function inserts linebreaks
      to separate tags that have nothing but whitespace between them.  It
      then indents the markup by using nxml's indentation rules."
        (interactive "r")
        (save-excursion
            (nxml-mode)
            (goto-char begin)
            (while (search-forward-regexp "\>[ \\t]*\<" nil t)
              (backward-char) (insert "\n"))
            (indent-region begin end)))
    #+END_SRC
*** tidy integration
    #+BEGIN_SRC emacs-lisp
      (require-package 'tidy)
      (add-hook 'nxml-mode-hook (lambda () (tidy-build-menu nxml-mode-map)))
   #+END_SRC
** PHP
   #+BEGIN_SRC emacs-lisp
     (require-package 'php-mode)
     (require-package 'smarty-mode)
   #+END_SRC
** Python
   #+BEGIN_SRC emacs-lisp
     (setq auto-mode-alist
           (append '(("SConstruct\\'" . python-mode)
                     ("SConscript\\'" . python-mode))
                   auto-mode-alist))
   #+END_SRC
** Rails
   #+BEGIN_SRC emacs-lisp
     (require-package 'rinari)
     (after-load 'rinari
       (diminish 'rinari-minor-mode "Rin"))
     (global-rinari-mode)

     (defun update-rails-ctags ()
       (interactive)
       (let ((default-directory (or (rinari-root) default-directory)))
         (shell-command (concat "ctags -a -e -f " rinari-tags-file-name " --tag-relative -R app lib vendor test"))))
   #+END_SRC
** Ruby
*** Basics
    #+BEGIN_SRC emacs-lisp
      (require-package 'ruby-mode)
      (require-package 'ruby-hash-syntax)

      (add-auto-mode 'ruby-mode
                     "Gemfile\\'"
                     "Kirkfile\\'"
                     "Rakefile\\'"
                     "\\.builder\\'"
                     "\\.gemspec\\'"
                     "\\.irbrc\\'"
                     "\\.pryrc\\'"
                     "\\.rake\\'"
                     "\\.rjs\\'"
                     "\\.ru\\'"
                     "\\.rxml\\'")

      (setq ruby-use-encoding-map nil)

      (after-load 'ruby-mode
        (define-key ruby-mode-map (kbd "RET") 'reindent-then-newline-and-indent)
        (define-key ruby-mode-map (kbd "TAB") 'indent-for-tab-command)

        ;; Stupidly the non-bundled ruby-mode isn't a derived mode of
        ;; prog-mode: we run the latter's hooks anyway in that case.
        (add-hook 'ruby-mode-hook
                  (lambda ()
                    (unless (derived-mode-p 'prog-mode)
                      (run-hooks 'prog-mode-hook)))))

      (add-hook 'ruby-mode-hook 'subword-mode)
    #+END_SRC
*** TODO hippie-expand ignores : for names in ruby-mode
*** Inferior Ruby
    #+BEGIN_SRC emacs-lisp
      (require-package 'inf-ruby)
    #+END_SRC
*** Compilation
    #+BEGIN_SRC emacs-lisp
      ;;; Ruby compilation
      (require-package 'ruby-compilation)

      (after-load 'ruby-mode
        (let ((m ruby-mode-map))
          (define-key m [S-f7] 'ruby-compilation-this-buffer)
          (define-key m [f7] 'ruby-compilation-this-test)
          (define-key m [f6] 'recompile)))
    #+END_SRC
*** Robe
    #+BEGIN_SRC emacs-lisp
      (require-package 'robe)
      (after-load 'ruby-mode
        (add-hook 'ruby-mode-hook 'robe-mode))
    #+END_SRC
*** Ri
    #+BEGIN_SRC emacs-lisp
      (require-package 'yari)
      (defalias 'ri 'yari)
    #+END_SRC
*** YAML
    #+BEGIN_SRC emacs-lisp
      (require-package 'yaml-mode)
    #+END_SRC
*** ERB
    #+BEGIN_SRC emacs-lisp
      (require-package 'mmm-mode)
      (defun jcf/ensure-mmm-erb-loaded ()
        (require 'mmm-erb))

      (require 'derived)

      (defun jcf/set-up-mode-for-erb (mode)
        (add-hook (derived-mode-hook-name mode) 'jcf/ensure-mmm-erb-loaded)
        (mmm-add-mode-ext-class mode "\\.erb\\'" 'erb))

      (let ((html-erb-modes '(html-mode html-erb-mode nxml-mode)))
        (dolist (mode html-erb-modes)
          (jcf/set-up-mode-for-erb mode)
          (mmm-add-mode-ext-class mode "\\.r?html\\(\\.erb\\)?\\'" 'html-js)
          (mmm-add-mode-ext-class mode "\\.r?html\\(\\.erb\\)?\\'" 'html-css)))

      (mapc 'jcf/set-up-mode-for-erb
            '(coffee-mode js-mode js2-mode js3-mode markdown-mode textile-mode))

      (mmm-add-mode-ext-class 'html-erb-mode "\\.jst\\.ejs\\'" 'ejs)

      (add-auto-mode 'html-erb-mode "\\.rhtml\\'" "\\.html\\.erb\\'")
      (add-to-list 'auto-mode-alist '("\\.jst\\.ejs\\'"  . html-erb-mode))
      (mmm-add-mode-ext-class 'yaml-mode "\\.yaml\\'" 'erb)

      (dolist (mode (list 'js-mode 'js2-mode 'js3-mode))
        (mmm-add-mode-ext-class mode "\\.js\\.erb\\'" 'erb))
    #+END_SRC
*** RSpec
    #+BEGIN_SRC emacs-lisp
      (require-package 'rspec-mode)

      (after-load 'ruby-mode
        (rspec-mode 1))
    #+END_SRC
*** Bundler
    #+BEGIN_SRC emacs-lisp
      (require-package 'bundler)
    #+END_SRC
*** TODO Inline SQL - fix or remove
    Adds support for syntax highlighting SQL in Ruby heredocs, for example:

    #+BEGIN_SRC ruby
      sql = <<-SQL
        SELECT * FROM users
        WHERE users.email = 'james@logi.cl'
        LIMIT 1
      SQL
    #+END_SRC

    Needs to run after rinari to avoid clobbering font-lock-keywords?
    Disabled for now.

    #+BEGIN_SRC emacs-lisp
      ;; (require-package 'mmm-mode)
      ;; (eval-after-load 'mmm-mode
      ;;   '(progn
      ;;      (mmm-add-classes
      ;;       '((ruby-heredoc-sql
      ;;          :submode sql-mode
      ;;          :front "<<-?[\'\"]?\\(SQL\\)[\'\"]?"
      ;;          :save-matches 1
      ;;          :front-offset (end-of-line 1)
      ;;          :back "^[ \t]*~1$"
      ;;          :delimiter-mode nil)))
      ;;      (mmm-add-mode-ext-class 'ruby-mode "\\.rb\\'" 'ruby-heredoc-sql)))
      ;;
      ;; (add-to-list 'mmm-set-file-name-for-modes 'ruby-mode)
   #+END_SRC
** Shell
*** Add ~.zsh~ files to ~sh-mode~
    #+BEGIN_SRC emacs-lisp
      (add-auto-mode 'sh-mode "\\.zsh\\'")
    #+END_SRC
*** Prezto support
    Recognise Prezto runcoms.

    #+BEGIN_SRC emacs-lisp
      (defvar jcf-pretzo-files '("zlogin"
                                 "zlogout"
                                 "zpretzorc"
                                 "zprofile"
                                 "zshenv"
                                 "zshrc"))

      (mapc (lambda (file)
              (add-to-list 'auto-mode-alist `(,(format "\\%s\\'" file) . sh-mode)))
            jcf-pretzo-files)
    #+END_SRC

    Use Z-Shell when we're editing a Prezto runcom.

    #+BEGIN_SRC emacs-lisp
      (add-hook
       'sh-mode-hook
       (lambda ()
         (if (and buffer-file-name
                  (member (file-name-nondirectory buffer-file-name) jcf-pretzo-files))
             (sh-set-shell "zsh"))))
    #+END_SRC
** Slim
   #+BEGIN_SRC emacs-lisp
     (require-package 'slim-mode)
   #+END_SRC
** Slime
   #+BEGIN_SRC emacs-lisp
     (require-package 'slime)
     ;; package.el compiles the contrib subdir, but the compilation order
     ;; causes problems, so we remove the .elc files there. See
     ;; http://lists.common-lisp.net/pipermail/slime-devel/2012-February/018470.html
     (mapc #'delete-file
           (file-expand-wildcards (concat user-emacs-directory "elpa/slime-2*/contrib/*.elc")))

     (require-package 'slime-company)
     (require-package 'hippie-expand-slime)

     
     ;;; Lisp buffers

     (defun jcf/slime-setup ()
       "Mode setup function for slime lisp buffers."
       (set-up-slime-hippie-expand))

     (after-load 'slime
       (setq slime-protocol-version 'ignore)
       (setq slime-net-coding-system 'utf-8-unix)
       (slime-setup '(slime-repl slime-fuzzy slime-company))
       (setq slime-complete-symbol*-fancy t)
       (setq slime-complete-symbol-function 'slime-fuzzy-complete-symbol)
       (add-hook 'slime-mode-hook 'jcf/slime-setup))

     
     ;;; REPL

     (defun jcf/slime-repl-setup ()
       "Mode setup function for slime REPL."
       (jcf/lisp-setup)
       (set-up-slime-hippie-expand)
       (set-up-slime-ac t)
       (setq show-trailing-whitespace nil))

     (after-load 'slime-repl
       ;; Bind TAB to `indent-for-tab-command', as in regular Slime buffers.
       (define-key slime-repl-mode-map (kbd "TAB") 'indent-for-tab-command)

       (add-hook 'slime-repl-mode-hook 'jcf/slime-repl-setup))
   #+END_SRC
** SQL
   #+BEGIN_SRC emacs-lisp
     (require-package 'sql-indent)
     (after-load 'sql
       (require 'sql-indent))

     (defun jcf/pop-to-sqli-buffer ()
       "Switch to the corresponding sqli buffer."
       (interactive)
       (if sql-buffer
           (progn
             (pop-to-buffer sql-buffer)
             (goto-char (point-max)))
         (sql-set-sqli-buffer)
         (when sql-buffer
           (jcf/pop-to-sqli-buffer))))

     (after-load 'sql
       (define-key sql-mode-map (kbd "C-c C-z") 'jcf/pop-to-sqli-buffer)
       (add-hook 'sql-interactive-mode-hook 'jcf/never-indent)
       (when (package-installed-p 'dash-at-point)
         (defun jcf/maybe-set-dash-db-docset ()
           (when (eq sql-product 'postgres)
             (setq dash-at-point-docset "psql")))

         (add-hook 'sql-mode-hook 'jcf/maybe-set-dash-db-docset)
         (add-hook 'sql-interactive-mode-hook 'jcf/maybe-set-dash-db-docset)
         (defadvice sql-set-product (after set-dash-docset activate)
           (jcf/maybe-set-dash-db-docset))))

     (setq-default sql-input-ring-file-name
                   (expand-file-name ".sqli_history" user-emacs-directory))

     (after-load 'page-break-lines
       (push 'sql-mode page-break-lines-modes))
   #+END_SRC
** TCL
   Minimal TCL support for creating Portfiles, used in [[https://guide.macports.org/chunked/development.html][MacPorts
   development]].

   #+BEGIN_SRC emacs-lisp
     (add-auto-mode 'tcl-mode "Portfile\\'")
   #+END_SRC
** Textile
   #+BEGIN_SRC emacs-lisp
     (require-package 'textile-mode)

     (autoload 'textile-mode "textile-mode" "Mode for editing Textile documents" t)
     (setq auto-mode-alist
           (cons '("\\.textile\\'" . textile-mode) auto-mode-alist))
   #+END_SRC
* Other packages
 #+BEGIN_SRC emacs-lisp
   (require-package 'dsvn)
   (require-package 'gnuplot)
   (require-package 'google-this)
   (require-package 'htmlize)
   (require-package 'regex-tool)
 #+END_SRC
* Miscellaneous
** Start server
   #+BEGIN_SRC emacs-lisp
     (defun jcf/start-server ()
       (require 'server)
       (unless (server-running-p)
         (server-start)))

     (add-hook 'after-init-hook 'jcf/start-server)
   #+END_SRC
** Load custom.el
   Generated customize variables.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (when (file-exists-p custom-file)
       (load custom-file))
   #+END_SRC
** Load init-local.el
   Allow users to provide an optional "init-local" containing personal settings

   #+BEGIN_SRC emacs-lisp
     (when (file-exists-p (expand-file-name "init-local.el" user-emacs-directory))
       (error "Please move init-local.el to ~/.emacs.d/lisp"))
     (require 'init-local nil t)
   #+END_SRC
* Locales
   Setting them earlier in this file doesn't work in X.

   #+BEGIN_SRC emacs-lisp
     (defun jcf/utf8-locale-p (v)
       "Return whether locale string V relates to a UTF-8 locale."
       (and v (string-match "UTF-8" v)))

     (defun locale-is-utf8-p ()
       "Return t iff the \"locale\" command or environment variables prefer UTF-8."
       (or (jcf/utf8-locale-p (and (executable-find "locale") (shell-command-to-string "locale")))
           (jcf/utf8-locale-p (getenv "LC_ALL"))
           (jcf/utf8-locale-p (getenv "LC_CTYPE"))
           (jcf/utf8-locale-p (getenv "LANG"))))

     (when (or window-system (locale-is-utf8-p))
       ;; Disable CJK coding/encoding (Chinese/Japanese/Korean characters)
       (setq utf-translate-cjk-mode nil)
       (set-language-environment 'utf-8)
       (setq locale-coding-system 'utf-8)
       (set-default-coding-systems 'utf-8)
       (set-terminal-coding-system 'utf-8)
       (unless (eq system-type 'windows-nt)
         (set-selection-coding-system 'utf-8))
       (prefer-coding-system 'utf-8))
   #+END_SRC
* Benchmark end
  #+BEGIN_SRC emacs-lisp
    (add-hook 'after-init-hook
              (lambda ()
                (message "init completed in %.2fms"
                         (jcf/time-subtract-millis after-init-time before-init-time))))
  #+END_SRC
